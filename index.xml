<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>从百草园到三味书屋</title><link>https://youngforever.tech/</link><description>Recent content on 从百草园到三味书屋</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 28 Oct 2024 17:53:00 +0000</lastBuildDate><atom:link href="https://youngforever.tech/index.xml" rel="self" type="application/rss+xml"/><item><title>医学人工智能周刊7｜医疗人工智能算法的公平性</title><link>https://youngforever.tech/ai4h/20241029-ai4h@7medicalfairness/</link><pubDate>Mon, 28 Oct 2024 17:53:00 +0000</pubDate><guid>https://youngforever.tech/ai4h/20241029-ai4h@7medicalfairness/</guid><description>&lt;h1 id="医疗人工智能算法的公平性" class="relative group">医疗人工智能算法的公平性 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%8c%bb%e7%96%97%e4%ba%ba%e5%b7%a5%e6%99%ba%e8%83%bd%e7%ae%97%e6%b3%95%e7%9a%84%e5%85%ac%e5%b9%b3%e6%80%a7" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h1>&lt;p>医疗领域，发展和部署不公平的人工智能系统会破坏公平治疗&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。在各亚人群中对AI模型的评估揭露了患者诊断、治疗以及收费上的不公平性。本文中作者从医疗角度概述了机器学习公平性，并且讨论算法偏差（特别是在数据获取、变异以及内在标签变异性）如何在临床工作流中出现并导致医疗差异。同样回顾了通过去纠缠、联邦学习和模型可解释性来减轻偏差的新兴的技术，以及这些方法在发展基于AI软件作为医疗设备的作用。&lt;/p>
&lt;h2 id="解决医疗差异和不平等的意义" class="relative group">解决医疗差异和不平等的意义 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%a7%a3%e5%86%b3%e5%8c%bb%e7%96%97%e5%b7%ae%e5%bc%82%e5%92%8c%e4%b8%8d%e5%b9%b3%e7%ad%89%e7%9a%84%e6%84%8f%e4%b9%89" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>医疗差异不平等的原因，有观察到和隐藏的危险因素，了解这些差异的根源将指导改善服务患者不足的医疗保健的决策政策。
基于含有混淆历史偏差的数据发展的算法可能造成差异伤害，评估和减轻算法造成的伤害是研究医疗机器学习的重要动力。&lt;/p>
&lt;h3 id="医疗差异" class="relative group">医疗差异 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%8c%bb%e7%96%97%e5%b7%ae%e5%bc%82" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>遗传变异和群体特异性表型：人种&lt;/li>
&lt;li>社会因素：地位财富等&lt;/li>
&lt;li>医学概念变化：ICD编码&lt;/li>
&lt;li>数据获取变化：数据获取的设备变化&lt;/li>
&lt;li>未知的医疗疾病：covid&lt;/li>
&lt;li>不同发展水平的国家部署AI-based software as medical device&lt;/li>
&lt;/ul>
&lt;h2 id="医疗公平衡量指标定义" class="relative group">医疗公平衡量指标定义 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%8c%bb%e7%96%97%e5%85%ac%e5%b9%b3%e8%a1%a1%e9%87%8f%e6%8c%87%e6%a0%87%e5%ae%9a%e4%b9%89" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;h3 id="demographic-parity" class="relative group">Demographic parity &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#demographic-parity" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>以关注的因素如种族划分亚组，在各亚组中模型阳性预测比例相等。&lt;/p>
&lt;h3 id="predictive-parity" class="relative group">Predictive parity &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#predictive-parity" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>阳性预测值（PPVs）和阴性预测值在各亚组应该相等。&lt;/p>
&lt;h3 id="equalized-odds" class="relative group">Equalized odds &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#equalized-odds" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>TPRs和FPRs在各亚组相等。&lt;/p>
&lt;h2 id="消除医疗ai不公开的技术" class="relative group">消除医疗AI不公开的技术 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%b6%88%e9%99%a4%e5%8c%bb%e7%96%97ai%e4%b8%8d%e5%85%ac%e5%bc%80%e7%9a%84%e6%8a%80%e6%9c%af" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>通过&lt;strong>预处理&lt;/strong>步骤调整现有算法，以盲化、增强或重新加权输入空间；&lt;/p>
&lt;ul>
&lt;li>importance weighting&lt;/li>
&lt;/ul>
&lt;p>为了消除混淆因素的影响，&lt;strong>处理中&lt;/strong>技术在模型中构建了一个非区分项，来惩罚学习保护特性中的区分特征；&lt;/p>
&lt;ul>
&lt;li>non-discrimination term&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>后处理&lt;/strong>通过改变模型的输出来满足公平性指标；&lt;/p>
&lt;ul>
&lt;li>pick thresholds for each group&lt;/li>
&lt;li>a calibration curve can be fitted for each group&lt;/li>
&lt;/ul>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>Chen R J, Wang J J, Williamson D F K, et al. Algorithmic fairness in artificial intelligence for medicine and healthcare[J]. Nature Biomedical Engineering, 2023, 7(6): 719-742.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>如何阅读论文</title><link>https://youngforever.tech/posts/20240410-how-to-read-a-paper/</link><pubDate>Tue, 09 Apr 2024 19:59:00 +0000</pubDate><guid>https://youngforever.tech/posts/20240410-how-to-read-a-paper/</guid><description>&lt;h2 id="introduction" class="relative group">Introduction &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#introduction" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>Efficiently read a paper is a critical but rarely taught skill.&lt;/p>
&lt;p>Describes the three-pass approach and its use in doing a literature survey.&lt;/p>
&lt;h2 id="the-three-pass-approach" class="relative group">The three-pass approach &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#the-three-pass-approach" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>The first pass gives you a general idea about the paper. The second pass lets you grasp the paper’s content, but not its details. The third pass helps you understand the paper in depth.&lt;/p>
&lt;h3 id="the-first-pass" class="relative group">The first pass &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#the-first-pass" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>A quick scan to get a bird’s-eye view of the paper, take about &lt;strong>five to ten minutes:&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>carefully read the title, abstract, and introduction&lt;/li>
&lt;li>read the section and sub-section headings, but ignore everything else&lt;/li>
&lt;li>read the conclusions&lt;/li>
&lt;li>glance over the references, mentally ticking off the ones you’ve already read&lt;/li>
&lt;/ul>
&lt;p>At the end of the first pass, you should be able to answer the 5Cs:&lt;/p>
&lt;ul>
&lt;li>Category: what type of paper is this?&lt;/li>
&lt;li>Context: which other papers is it related to? which theoretical bases were used?&lt;/li>
&lt;li>Correctness: Do the assumptions appear to be valid?&lt;/li>
&lt;li>Contributions: what are the paper’s main contributions?&lt;/li>
&lt;li>Clarity: Is the paper well written&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>think as a reviewer:&lt;/strong> if a reviewer cannot understand the gist after one pass, the paper may be rejected.&lt;/p>
&lt;h3 id="the-second-pass" class="relative group">The second pass &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#the-second-pass" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>read the paper with greater care, but ignore details such as proofs, take up to an hour.&lt;/p>
&lt;ul>
&lt;li>look carefully at the figures, diagrams and other illustrations&lt;/li>
&lt;li>mark relevant unread reference for further reading&lt;/li>
&lt;/ul>
&lt;h3 id="the-third-pass" class="relative group">The third pass &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#the-third-pass" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>Take about four or five hours for beginners, and about an hour for an experienced reader.&lt;/p>
&lt;ul>
&lt;li>virtually re-implement the paper&lt;/li>
&lt;/ul>
&lt;h2 id="doing-a-literature-survey" class="relative group">Doing a literature survey &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#doing-a-literature-survey" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ul>
&lt;li>Use academic search engine to find &lt;strong>there to five recent papers&lt;/strong> in the area
&lt;ul>
&lt;li>read their related work&lt;/li>
&lt;li>&lt;strong>a recent survey paper&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Find shared citations and repeated author names in the bibliography
&lt;ul>
&lt;li>&lt;strong>download the key papers (1)&lt;/strong>&lt;/li>
&lt;li>find where the best researchers published recently&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Go to the website for these top conferences or journals and look through their recent proceedings
&lt;ul>
&lt;li>&lt;strong>identify recent high-quality related work(2)&lt;/strong>&lt;/li>
&lt;li>constitute the first version of survey from (1) and (2)&lt;/li>
&lt;li>obtain key paper you didn’t find in these papers, obtain and read it&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="reference" class="relative group">Reference &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#reference" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>Keshav S. How to Read a Paper.&lt;/p></description></item><item><title>Skip-gram模型（2）</title><link>https://youngforever.tech/posts/20230205-skip-gram-part2/</link><pubDate>Wed, 12 Jul 2023 19:36:02 +0000</pubDate><guid>https://youngforever.tech/posts/20230205-skip-gram-part2/</guid><description>
&lt;script>
document.addEventListener("DOMContentLoaded", function() {
renderMathInElement(document.body, {
delimiters: [
{left: '$$', right: '$$', display: true},
{left: '$', right: '$', display: false},
{left: '\\(', right: '\\)', display: false},
{left: '\\[', right: '\\]', display: true}
],
throwOnError : false
});
});
&lt;/script>
&lt;blockquote>
&lt;p>&lt;a href="https://youngforever.tech/posts/20230205-skip-gram-part1/" target="_blank" rel="noreferrer">之前文章&lt;/a>介绍了skip-gram的原理，这篇文章给出模型的实现细节以及pytorch和tensorflow的实现。&lt;/p>
&lt;/blockquote>
&lt;h2 id="回顾" class="relative group">回顾 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%9b%9e%e9%a1%be" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>假如用余弦相似度来计算两个词的one-hot编码得到0，即不能编码词之间的相似性，所以有了word2vec的方法，包括skip-gram和CBOW。&lt;/p>
&lt;p>接前文，假如我们拥有10000个单词的词汇表，想嵌入300维的词向量，那么我们的&lt;strong>输入-隐层权重矩阵&lt;/strong>和&lt;strong>隐层-输出层的权重矩阵&lt;/strong>都会有 10000 x 300 = 300万个权重，在如此庞大的神经网络中进行梯度下降是相当慢的。更糟糕的是，你需要大量的训练数据来调整这些权重并且避免过拟合。百万数量级的权重矩阵和亿万数量级的训练样本意味着训练这个模型将会是个灾难。&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup> 所以在具体实践上有一些计算技巧。&lt;/p>
&lt;h2 id="计算" class="relative group">计算 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%ae%a1%e7%ae%97" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>skip-gram模型基于单个输入来预测上下文，对于T个训练单词$w_1,&amp;hellip;w_T$，即最大化以下概率$$\frac{1}{T}\sum_{t=1}^T\sum_{-c&amp;lt;=j&amp;lt;=c}logP(w_{t+j}|w_t)\tag1$$其中c为训练上下文的窗口大小，$p(w_{t+j}|w_t)$用softmax来计算$$p(w_o|w_i)=\frac{exp(v_{wo}^Tv_{wi})}{\sum_{w=1}^Wexp(v_{wo}^Tv_{wi})}$$其中$v_{wi}$为输入词向量的表征，在单词量W巨大的情况下（通常都有$10^5-10^7$），式1的计算开销巨大。&lt;/p>
&lt;p>在skip-gram实际算法中使用多种策略来减少模型的资源使用（内存）以及提高词向量表征质量&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;/p>
&lt;ul>
&lt;li>负采样
&lt;ul>
&lt;li>从隐藏层到输出的Softmax层的计算量很大，因为要计算所有词的Softmax概率，再去找概率最大的值。例如当我们用训练样本 ( input word: &amp;ldquo;fox&amp;rdquo;，output word: &amp;ldquo;quick&amp;rdquo;) 来训练我们的神经网络时，“ fox”和“quick”都是经过one-hot编码的。如果我们的vocabulary大小为10000时，在输出层，我们期望对应“quick”单词的那个神经元结点输出1，其余9999个都应该输出0。在这里，这9999个我们期望输出为0的神经元结点所对应的单词我们称为“negative” word。&lt;strong>当使用负采样时，我们将随机选择一小部分的negative words（比如选5个negative words）来更新对应的权重&lt;/strong>, 我们也会对我们的“positive” word进行权重更新&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>。在实践中，​通常使用的是unigram分布的平方根，​即词汇表中每个词的概率的0.75次方除以归一化常数来挑选负样本。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>高频词进行抽样
&lt;ul>
&lt;li>原因：高频词相对于低频词来说提供的信息少；高频词随着样本增多本身表示也不会发生太大变化&lt;/li>
&lt;li>使用概率P来丢掉一定的单词$$P(w)=1- \sqrt{\frac{t}{f(w_i)}}$$其中t为设定的阈值，$f(w_i)$为单词出现的频率，可以看到频率越高丢弃的概率越大，反之越小&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>单词组合成词组作为单个词处理
&lt;ul>
&lt;li>原因：组合词有特定的意思，不是简单把单个词的表示聚合起来&lt;/li>
&lt;li>如何从文本中提取出词组研究不少，skip-gram文章选用了$$socre(w_i, w_j)=\frac{count(w_iw_j)-\delta}{count(w_i)*count(w_j)}$$其中$w_i, w_j$代表不同的单词，利用score得分与设定的阈值比较来确定是否为常见词组&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="skip-gram-pytorch实现" class="relative group">skip-gram PyTorch实现 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#skip-gram-pytorch%e5%ae%9e%e7%8e%b0" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>Word2vec skip-gram pytorch&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>&lt;/p>
&lt;p>&lt;a href="https://github.com/yongfanbeta/skip-gram/blob/main/skipgram-pytorch.ipynb" target="_blank" rel="noreferrer">skipgram-pytorch.ipynb&lt;/a>&lt;/p>
&lt;h2 id="skip-gram-tensorflow实现" class="relative group">skip-gram Tensorflow实现 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#skip-gram-tensorflow%e5%ae%9e%e7%8e%b0" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>Word2vec skip-gram tensorflow&lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup>&lt;/p>
&lt;p>&lt;a href="https://github.com/yongfanbeta/skip-gram/blob/main/skipgram-tf.ipynb" target="_blank" rel="noreferrer">skipgram-tf.ipynb&lt;/a>&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/27234078" target="_blank" rel="noreferrer">理解 Word2Vec 之 Skip-Gram 模型 - 知乎&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>&lt;a href="https://arxiv.org/pdf/1310.4546.pdf" target="_blank" rel="noreferrer">Distributed Representations of Words and Phrases and their Compositionality&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>&lt;a href="https://www.jianshu.com/p/cf36d4c1ea39" target="_blank" rel="noreferrer">关于skip-gram和负采样 - 简书&lt;/a>&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>&lt;a href="http://zh.d2l.ai/chapter_natural-language-processing-pretraining/word2vec.html" target="_blank" rel="noreferrer">14.1. 词嵌入（word2vec） — 动手学深度学习 2.0.0 documentation&lt;/a>&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5">
&lt;p>&lt;a href="https://www.tensorflow.org/tutorials/text/word2vec#negative_sampling_for_one_skip-gram" target="_blank" rel="noreferrer">word2vec  |  TensorFlow Core&lt;/a>&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>医学人工智能周刊6｜模态无关的学习方法在医学影像以及生理信号中的评测</title><link>https://youngforever.tech/ai4h/20230711-ai4h@6/</link><pubDate>Mon, 10 Jul 2023 20:00:00 +0000</pubDate><guid>https://youngforever.tech/ai4h/20230711-ai4h@6/</guid><description>&lt;h2 id="摘要" class="relative group">摘要 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%91%98%e8%a6%81" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>目的：建立基准测试BenchMD，用于测试模型无关的方法包括&lt;strong>架构&lt;/strong>和&lt;strong>训练技术&lt;/strong>（例如自监督学习、预训练）在临床相关的医疗任务上的表现。简言之，就是测试最新一些通用人工智能方法在医疗任务上的表现。&lt;/p>
&lt;p>BenchMD包括19个公开数据集，7种医疗数据模态，1维传感器数据、2维图片、3维扫描数据。&lt;/p>
&lt;p>结果表明，没有一种与模态无关的技术在所有模态上都能实现强大的性能，基准模型有充足的改进空间。&lt;/p>
&lt;h2 id="引言" class="relative group">引言 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%bc%95%e8%a8%80" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>背景：Transformers模型和自监督学习（SSL）对标签数据需求小、能灵活运用到多种模态的数据。&lt;/p>
&lt;p>问题：衡量这些进展在领域内的效果需要制定具有广度和深度的评测，以捕捉应用和模式的多样性，并通过让专家参与评测过程来确保外部有效性。&lt;/p>
&lt;p>当前医疗AI领域应用时针对具体问题，通过试验选择不同的架构以及自监督学习方法，期望发展一种灵活、与模态无关无需定制化就能应用到各类问题的方法。&lt;/p>
&lt;p>解决：BenchMD针对每种模态构建标准化、临床有效的评估方法，并通过专家验证；同时探索了基准&lt;strong>数据标签不足&lt;/strong>情况和&lt;strong>数据偏移&lt;/strong>情况下的表现；&lt;/p>
&lt;p>同时，为了让BenchMD更加容易使用：&lt;/p>
&lt;ul>
&lt;li>易用性：新架构和任务即插即用&lt;/li>
&lt;li>易复现：全部使用公开数据集&lt;/li>
&lt;/ul>
&lt;p>结果显示医疗AI领域通用、泛化性强方法仍需继续研究。&lt;/p>
&lt;h2 id="相关工作" class="relative group">相关工作 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e7%9b%b8%e5%85%b3%e5%b7%a5%e4%bd%9c" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ul>
&lt;li>模态无关的技术：SSL
&lt;ul>
&lt;li>掩码建模&lt;/li>
&lt;li>对比学习&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>模态无关的医学人工智能
&lt;ul>
&lt;li>在医学图像上自监督MAE比ImageNet上预训练要好&lt;/li>
&lt;li>医学影像有无监督预训练加上监督学习表现好&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>现有多种模态的基准测试
&lt;ul>
&lt;li>&lt;a href="https://github.com/alextamkin/dabs" target="_blank" rel="noreferrer">GitHub - alextamkin/dabs: A Domain-Agnostic Benchmark for Self-Supervised Learning&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/p-lambda/wilds" target="_blank" rel="noreferrer">GitHub - p-lambda/wilds: A machine learning benchmark of in-the-wild distribution shifts, with data loaders, evaluators, and default models.&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="模态和数据集" class="relative group">模态和数据集 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%a8%a1%e6%80%81%e5%92%8c%e6%95%b0%e6%8d%ae%e9%9b%86" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>整理了一系列高影响模态数据以及精心挑选的数据源和目标数据集，用于评估分布外 （OOD） 性能。&lt;/p>
&lt;h3 id="12-lead-ecgs" class="relative group">12-lead ECGs &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#12-lead-ecgs" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>利用5秒采样频率为500Hz的12导心电数据进行7分类：正常、传导障碍、心肌肥厚、心肌梗死、缺血性ST-T改变、心房颤动/心房扑动及其他。&lt;/p>
&lt;p>数据包括：&lt;/p>
&lt;ul>
&lt;li>PTB-XL (18k) 1989-1996
&lt;ul>
&lt;li>&lt;a href="https://physionet.org/content/ptb-xl/1.0.3/" target="_blank" rel="noreferrer">PTB-XL, a large publicly available electrocardiography dataset v1.0.3&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Chapman-Shaoxing (10k) 2020
&lt;ul>
&lt;li>&lt;a href="https://figshare.com/collections/ChapmanECG/4560497/2" target="_blank" rel="noreferrer">A 12-lead electrocardiogram database for arrhythmia research covering more than 10,000 patients&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Georgia 12-Lead ECG Challenge (10k) 2020
&lt;ul>
&lt;li>&lt;a href="https://physionet.org/content/challenge-2020/1.0.2/#files" target="_blank" rel="noreferrer">Classification of 12-lead ECGs: The PhysioNet/Computing in Cardiology Challenge 2020 v1.0.2&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>China Physiological Signal Challenge (6.8k) 2018&lt;/li>
&lt;/ul>
&lt;h3 id="eeg" class="relative group">EEG &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#eeg" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>30秒单导EEG睡眠分期任务。使用AASM睡眠分期标准：觉醒、快速眼动、非快速眼动I期、非快速眼动2期、非快速眼动3期。&lt;/p>
&lt;p>数据包括：&lt;/p>
&lt;ul>
&lt;li>SHHS (5.8k) 1995-1998
&lt;ul>
&lt;li>includes 5,804 adults aged 40 and older&lt;/li>
&lt;li>&lt;a href="https://biolincc.nhlbi.nih.gov/studies/shhs/" target="_blank" rel="noreferrer">BioLINCC: Sleep Heart Health Study (SHHS)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>ISRUC-Sleep（0.1k）2009-2013
&lt;ul>
&lt;li>collected from subjects in hospital whose ages range from 20 years old to 85 years old, with an average age of 51&lt;/li>
&lt;li>&lt;a href="https://sleeptight.isr.uc.pt/" target="_blank" rel="noreferrer">ISRUC-SLEEP Dataset | A comprehensive public dataset for sleep researchers&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="chest-x-rays" class="relative group">Chest X-Rays &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#chest-x-rays" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>使用2D灰度胸片进行单标签分类任务，包括肺不张、心脏扩大、实变、水肿和胸腔积液。&lt;/p>
&lt;p>数据包括：&lt;/p>
&lt;ul>
&lt;li>MIMIC-CXR (227k) 2011-2016
&lt;ul>
&lt;li>a large publicly available dataset of chest radiographs in DICOM format with free-text radiology reports.&lt;/li>
&lt;li>&lt;a href="https://physionet.org/content/mimic-cxr/2.0.0/" target="_blank" rel="noreferrer">MIMIC-CXR Database v2.0.0&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CheXpert (65k) 2002-2017
&lt;ul>
&lt;li>a large public dataset for chest radiograph interpretation, consisting of 224,316 chest radiographs of 65,240 patients.&lt;/li>
&lt;li>[CheXpert: A Large Chest Radiograph Dataset with Uncertainty Labels and Expert Comparison](&lt;a href="https://stanfordmlgroup.github.io/competitions/chexpert/" target="_blank" rel="noreferrer">https://stanfordmlgroup.github.io/competitions/chexpert/&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>VinDr-CXR (18k) 2018-2020
&lt;ul>
&lt;li>The published dataset consists of 18,000 postero-anterior (PA) view CXR scans that come with both the localization of critical findings and the classification of common thoracic diseases.&lt;/li>
&lt;li>&lt;a href="https://vindr.ai/datasets/cxr" target="_blank" rel="noreferrer">VinDr-CXR: An open dataset and benchmarks for disease classification and abnormality localization on chest radiographs | VinDr&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="mammograms" class="relative group">Mammograms &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#mammograms" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>乳腺X光检查包括患者左右乳房不同视图的2D灰度图像从1-5类BI-RADS分级。&lt;/p>
&lt;p>数据包括：&lt;/p>
&lt;ul>
&lt;li>VinDr-Mammo (5k) 2018-2020
&lt;ul>
&lt;li>a large-scale benchmark dataset of full-field digital mammography, called VinDr-Mammo&lt;/li>
&lt;li>&lt;a href="https://vindr.ai/datasets/mammo" target="_blank" rel="noreferrer">VinDr-Mammo: A large-scale benchmark dataset for computer-aided diagnosis in full-field digital mammography | VinDr&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>CBIS-DDSM (2.6k)1988-1999
&lt;ul>
&lt;li>The DDSM is a database of 2,620 scanned film mammography studies. It contains normal, benign, and malignant cases with verified pathology information.&lt;/li>
&lt;li>&lt;a href="https://wiki.cancerimagingarchive.net/pages/viewpage.action?pageId=22516629" target="_blank" rel="noreferrer">Curated Breast Imaging Subset of Digital Database for Screening Mammography (CBIS-DDSM) - The Cancer Imaging Archive (TCIA) Public Access - Cancer Imaging Archive Wiki&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="dermoscopic" class="relative group">Dermoscopic &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#dermoscopic" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>基于2D RGB皮肤图像进行单标签分类，共5类：AKIEC“（包括光化性角化病、上皮内癌和鳞状细胞癌，因为所有这些都是鳞状细胞癌的连续体）、”BCC“（基底细胞癌）、”MEL“（黑色素瘤）、”NEV“（痣）和”其他疾病“（皮肤纤维瘤等）。&lt;/p>
&lt;p>数据包括：&lt;/p>
&lt;ul>
&lt;li>BCN20000（19k）2010-2016
&lt;ul>
&lt;li>paper: &lt;a href="https://arxiv.org/pdf/1908.02288.pdf" target="_blank" rel="noreferrer">BCN20000: DERMOSCOPIC LESIONS IN THE WILD&lt;/a>&lt;/li>
&lt;li>data: &lt;a href="https://challenge.isic-archive.com/data/#2019" target="_blank" rel="noreferrer">ISIC Challenge&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>HAM10000（10k）
&lt;ul>
&lt;li>paper: &lt;a href="https://www.nature.com/articles/sdata2018161" target="_blank" rel="noreferrer">The HAM10000 dataset, a large collection of multi-source dermatoscopic images of common pigmented skin lesions | Scientific Data&lt;/a>&lt;/li>
&lt;li>data: &lt;a href="https://isic-archive.com/" target="_blank" rel="noreferrer">ISIC | International Skin Imaging Collaboration&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>PAD-UFES-20（1.37k）2018-2019
&lt;ul>
&lt;li>a nonprofit program that provides free skin lesion treatment, in particular, to low-income people who cannot afford private treatment.&lt;/li>
&lt;li>paper: &lt;a href="https://arxiv.org/abs/2007.00478" target="_blank" rel="noreferrer">[2007.00478] PAD-UFES-20: a skin lesion dataset composed of patient data and clinical images collected from smartphones&lt;/a>&lt;/li>
&lt;li>data: &lt;a href="https://data.mendeley.com/datasets/zr7vgbcyr2/1" target="_blank" rel="noreferrer">PAD-UFES-20: a skin lesion dataset composed of patient data and clinical images collected from smartphones - Mendeley Data&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="fundus-images" class="relative group">Fundus Images &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#fundus-images" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>基于2D RGB眼底图像预测糖尿病视网膜病变严重程度，基于ICDR分级共5类&lt;/p>
&lt;p>数据包括：&lt;/p>
&lt;ul>
&lt;li>Messidor-2（0.5k）2004-2010
&lt;ul>
&lt;li>a collection of Diabetic Retinopathy (DR) examinations, each consisting of two macula-centered eye fundus images (one per eye)&lt;/li>
&lt;li>&lt;a href="https://www.adcis.net/en/third-party/messidor2/" target="_blank" rel="noreferrer">Messidor-2 - ADCIS&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>APTOS 2019（3.6k）2019
&lt;ul>
&lt;li>3662 samples collected from many participants of rural India&lt;/li>
&lt;li>&lt;a href="https://www.kaggle.com/competitions/aptos2019-blindness-detection/data" target="_blank" rel="noreferrer">APTOS 2019 Blindness Detection | Kaggle&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Jinchi Medical University dataset（2.7k）2011-2015
&lt;ul>
&lt;li>paper：&lt;a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5480986/#:~:text=Here%2C%20we%20show%20an%20AI%20that%20grades%20diabetic,staging%20and%20can%20suggest%20treatments%20and%20predict%20prognoses." target="_blank" rel="noreferrer">Applying artificial intelligence to disease staging: Deep learning for improved staging of diabetic retinopathy - PMC&lt;/a>&lt;/li>
&lt;li>data：&lt;a href="https://figshare.com/articles/figure/Davis_Grading_of_One_and_Concatenated_Figures/4879853/1" target="_blank" rel="noreferrer">Davis Grading of One and Concatenated Figures&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="low-dose-computer-tomography-scansldct" class="relative group">Low Dose Computer Tomography Scans（LDCT） &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#low-dose-computer-tomography-scansldct" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>基于3D CT影像进行判断结节大小&lt;/p>
&lt;p>数据包括：&lt;/p>
&lt;ul>
&lt;li>LIDC-IDRI（1.0k）2010
&lt;ul>
&lt;li>&lt;a href="https://wiki.cancerimagingarchive.net/pages/viewpage.action?pageId=1966254" target="_blank" rel="noreferrer">Data from The Lung Image Database Consortium (LIDC) and Image Database Resource Initiative (IDRI): A completed reference database of lung nodules on CT scans (LIDC-IDRI) - The Cancer Imaging Archive (TCIA) Public Access - Cancer Imaging Archive Wiki&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>LNDb（294）2016-2018
&lt;ul>
&lt;li>&lt;a href="https://zenodo.org/record/7153205" target="_blank" rel="noreferrer">LNDb Dataset | Zenodo&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="实验" class="relative group">实验 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%ae%9e%e9%aa%8c" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>对5种技术进行评估：3种SSL算法、ImageNet预训练、从头训练，然后使用多种迁移学习方法测试在分布外（OOD）数据中性能。&lt;/p>
&lt;h3 id="网络架构" class="relative group">网络架构 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e7%bd%91%e7%bb%9c%e6%9e%b6%e6%9e%84" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>分别使用1D、2D和3D的embedding模块处理原始数据形成256维度的嵌入空间，不同输入维度的信息能混合。编码器使用的是标准的ViT架构。&lt;/p>
&lt;h3 id="预训练" class="relative group">预训练 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e9%a2%84%e8%ae%ad%e7%bb%83" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>三种自监督方法&lt;/p>
&lt;ul>
&lt;li>Contrastive embedding-Mixup(e-Mix)
&lt;ul>
&lt;li>使用一定的比例系数对原始输入嵌入加权并相加，训练编码器为混合输入产生一个向量，该向量与原始输入经过混合因子加权相加尽量相近&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Shuffled embedding prediction(ShED)
&lt;ul>
&lt;li>打乱一部分输入嵌入，使用带分类器的编码器来预测被扰动过的嵌入&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>MAE
&lt;ul>
&lt;li>对输入嵌入表达进行75%的掩码，训练模型重建输入对嵌入表达&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="迁移学习以及分布外评价" class="relative group">迁移学习以及分布外评价 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%bf%81%e7%a7%bb%e5%ad%a6%e4%b9%a0%e4%bb%a5%e5%8f%8a%e5%88%86%e5%b8%83%e5%a4%96%e8%af%84%e4%bb%b7" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>固定模型骨架利用分布内数据训练一个线性分类器进行微调。然后在分布外数据集中进行zero-shot评估。微调数据集的选取，单标签任务选取，多标签任务选取。&lt;/p>
&lt;p>
&lt;figure>&lt;img src="https://cdn.jsdelivr.net/gh/jmwyf/pichosting@master/benchmdpng" alt="" class="mx-auto my-0 rounded-md" />
&lt;/figure>
&lt;/p>
&lt;h2 id="结果" class="relative group">结果 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e7%bb%93%e6%9e%9c" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ul>
&lt;li>各类自监督方法在各模态数据上表现不一致，需要探索在各模态数据中表现更加一致的SSL算法&lt;/li>
&lt;li>SSL有时优于预训练方法，有时预训练也可以和SSL表现相当。&lt;strong>未来需要探索在其他数据集例如imagenet中进行预训练，然后在医疗数据集中进行SSL&lt;/strong>，即预训练与自监督结合。&lt;/li>
&lt;li>微调过程中标化数据量影响模型性能，越多越好，但也要防止过拟合的情况发生。&lt;/li>
&lt;li>分布内与分布外数据模型性能比较表明需要探索提升模型可泛化性能的正则化技术&lt;/li>
&lt;/ul>
&lt;h2 id="思考" class="relative group">思考 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%80%9d%e8%80%83" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>自监督技术和预训练技术在NLP和CV领域应用广泛，如何应用到各类医疗数据中，是不是在所有种类的医疗数据中表现都比不使用要好，本文通过构建各类基准模型尝试回答该问题，相比于NLP和CV领域，医疗领域数据种类繁多导致当前没有一种统一的方法适用于所有的情形，需要进一步研究判断对各种类的数据适合使用的方法，以及预训练与自监督技术联合使用的方法。&lt;/p>
&lt;blockquote>
&lt;p>Wantlin, K. et al. BenchMD: A Benchmark for Modality-Agnostic Learning on Medical Images and Sensors. Preprint at &lt;a href="https://doi.org/10.48550/arXiv.2304.08486" target="_blank" rel="noreferrer">https://doi.org/10.48550/arXiv.2304.08486&lt;/a> (2023).&lt;/p>
&lt;/blockquote></description></item><item><title>医学人工智能周刊5｜提高医疗领域AI算法研究透明性清单</title><link>https://youngforever.tech/ai4h/20230624-ai4h@5/</link><pubDate>Fri, 23 Jun 2023 20:00:00 +0000</pubDate><guid>https://youngforever.tech/ai4h/20230624-ai4h@5/</guid><description>&lt;h2 id="有关临床人工智能建模的最小信息mi-claim检查清单" class="relative group">有关临床人工智能建模的最小信息：MI-CLAIM检查清单 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%9c%89%e5%85%b3%e4%b8%b4%e5%ba%8a%e4%ba%ba%e5%b7%a5%e6%99%ba%e8%83%bd%e5%bb%ba%e6%a8%a1%e7%9a%84%e6%9c%80%e5%b0%8f%e4%bf%a1%e6%81%afmi-claim%e6%a3%80%e6%9f%a5%e6%b8%85%e5%8d%95" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>一种用于提高医疗领域AI算法透明性报告的工具&lt;/p>
&lt;h3 id="研究设计" class="relative group">研究设计 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e7%a0%94%e7%a9%b6%e8%ae%be%e8%ae%a1" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 模型解决的临床问题在论文中有清楚的细节&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 清晰的表述研究问题&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 患者队列的特征有细节文本体现&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 患者队列能代表真实世界临床环境&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 确定并详细说明用于基线比较最先进的解决方案&lt;/li>
&lt;/ul>
&lt;h3 id="数据和优化" class="relative group">数据和优化 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%95%b0%e6%8d%ae%e5%92%8c%e4%bc%98%e5%8c%96" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 原始数据以及原始格式在文中描述清楚&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 用于模型的数据转化被详细描述&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 训练集和测试集说吗相互独立&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 描述关于如何选择最优模型的细节&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 输入数据是结构化还是非结构化&lt;/li>
&lt;/ul>
&lt;h3 id="模型性能" class="relative group">模型性能 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%a8%a1%e5%9e%8b%e6%80%a7%e8%83%bd" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 描述用于评价算法性能（AUC、F-score等）的主要指标，包括选择依据&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 描述用于评价模型临床利用（PPV、NNT等）的主要指标，包括选择依据&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 使用合适的统计学方法描述比较提出模型性能与基线模型的性能&lt;/li>
&lt;/ul>
&lt;h3 id="模型测试" class="relative group">模型测试 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%a8%a1%e5%9e%8b%e6%b5%8b%e8%af%95" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 检查技术1，结构化数据系数以及敏感度分析&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 检查技术2，非结构化数据显著图以及敏感度分析&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 讨论模型/算法性能与检查结果相关性&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 讨论在检查方法不可解释的情况下，在案例层面模型可解释性的可行性与意义&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 讨论在底层数据分布偏移情况下模型的可靠性以及鲁棒性&lt;/li>
&lt;/ul>
&lt;h3 id="可重复性" class="relative group">可重复性 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%8f%af%e9%87%8d%e5%a4%8d%e6%80%a7" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> 完成代码分享&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 允许第三方评测代码的准确性/公平性；分享评测结果&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 发布用于在新数据上运行代码而不共享其详细信息的虚拟机(二进制文件)&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> 不分享&lt;/li>
&lt;/ul>
&lt;p>&lt;a href="https://www.nature.com/articles/s41591-020-1041-y" target="_blank" rel="noreferrer">Minimum information about clinical artificial intelligence modeling: the MI-CLAIM checklist | Nature Medicine&lt;/a>&lt;/p></description></item><item><title>医学人工智能周刊4｜如何解决医学人工智能的可解释性</title><link>https://youngforever.tech/ai4h/20230624-ai4h@4/</link><pubDate>Fri, 23 Jun 2023 19:57:00 +0000</pubDate><guid>https://youngforever.tech/ai4h/20230624-ai4h@4/</guid><description>&lt;h2 id="构建临床医生需求与开发目标之间的桥梁来解决医学人工智能可解释性" class="relative group">构建临床医生需求与开发目标之间的桥梁来解决医学人工智能可解释性 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%9e%84%e5%bb%ba%e4%b8%b4%e5%ba%8a%e5%8c%bb%e7%94%9f%e9%9c%80%e6%b1%82%e4%b8%8e%e5%bc%80%e5%8f%91%e7%9b%ae%e6%a0%87%e4%b9%8b%e9%97%b4%e7%9a%84%e6%a1%a5%e6%a2%81%e6%9d%a5%e8%a7%a3%e5%86%b3%e5%8c%bb%e5%ad%a6%e4%ba%ba%e5%b7%a5%e6%99%ba%e8%83%bd%e5%8f%af%e8%a7%a3%e9%87%8a%e6%80%a7" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>可解释人工智能（XAI）已成为AI/ML在医疗领域实践应用一种有前途的解决方法。然而，开发者和临床人员如何解释XAI，以及他们之间冲突的目标和需求不太清楚。这篇文章介绍了一项纵向多种方法（调查问卷、实验、采访）的研究结果，该研究涉及112个开发人员和临床人员共同设计用于临床决策支持系统（CDSS）的XAI解决方案。本研究确定了XAI在开发者和临床医生心智模型中3个重要的差别，包括对立的目标（模型可解释性与临床合理性），不同事实来源（数据vs患者），以及探索新知识和利用旧知识。基于上述发现，文中提出能帮助解决医疗领域XAI难题的解决方案，包括利用因果推断模型，个性化解释以及探索和利用间的平衡。本研究强调在XAI系统设计中同时考虑开发者和临床医生角度观点的重要性并且提供提高医疗领域XAI有效性和可用性的实用建议。&lt;/p>
&lt;p>
&lt;figure>&lt;img src="https://cdn.jsdelivr.net/gh/jmwyf/pichosting@master/XAI.png" alt="" class="mx-auto my-0 rounded-md" />
&lt;/figure>
&lt;/p>
&lt;p>&lt;a href="https://www.nature.com/articles/s41746-023-00837-4" target="_blank" rel="noreferrer">Solving the explainable AI conundrum by bridging clinicians’ needs and developers’ goals | npj Digital Medicine&lt;/a>&lt;/p>
&lt;h2 id="医学影像人工智能解释的现状与未来" class="relative group">医学影像人工智能解释的现状与未来 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%8c%bb%e5%ad%a6%e5%bd%b1%e5%83%8f%e4%ba%ba%e5%b7%a5%e6%99%ba%e8%83%bd%e8%a7%a3%e9%87%8a%e7%9a%84%e7%8e%b0%e7%8a%b6%e4%b8%8e%e6%9c%aa%e6%9d%a5" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>医学影像的解释是放射科医生工作的核心任务，近年来人工智能应用逐渐参与其中。这篇文章回顾了影像人工智能模型发展及其在临床实践中应用的进展、挑战和机遇。文章讨论了AI算法帮助放射科医生完成包括检查、工作流分类以及量化的功能，也讨论了非影像科医生使用医学影像AI的趋势。文章指出了在放射学使用AI算法时泛化的核心挑战，以及对包含临床医生-AI合作、透明度以及部署后监测的验证保障措施的需求。最后，文章讨论了人工智能领域多模态LLM的快速发展，这一进展为开发通用医疗人工智能模型提供了重大机遇，这些模型可以处理各种医学影像解释任务等。&lt;/p>
&lt;p>
&lt;figure>&lt;img src="https://cdn.jsdelivr.net/gh/jmwyf/pichosting@master/AIinterpretation.png" alt="" class="mx-auto my-0 rounded-md" />
&lt;/figure>
&lt;/p>
&lt;p>&lt;a href="https://doi.org/10.1056/NEJMra2301725" target="_blank" rel="noreferrer">The Current and Future State of AI Interpretation of Medical Images | NEJM&lt;/a>&lt;/p>
&lt;h2 id="基于深度学习方法从疾病轨迹中预测胰腺癌风险" class="relative group">基于深度学习方法从疾病轨迹中预测胰腺癌风险 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%9f%ba%e4%ba%8e%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0%e6%96%b9%e6%b3%95%e4%bb%8e%e7%96%be%e7%97%85%e8%bd%a8%e8%bf%b9%e4%b8%ad%e9%a2%84%e6%b5%8b%e8%83%b0%e8%85%ba%e7%99%8c%e9%a3%8e%e9%99%a9" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>胰腺癌是一种侵袭性疾病，通常表现较晚结局较差，这意味着需要早期诊断。本研究中，将人工智能方法应用在丹麦（丹麦国家患者登记处，DNPR）六百万患者（24000胰腺癌患者病例）和美国（美国退伍军人事务部，US-VA）三百万患者（3900胰腺癌病例）的临床数据中，在临床病史的疾病代码序列中训练机器学习模型，并在逐渐增加的时间窗口中测试预测癌症发生率。对于在36个月内的发生癌症，DNPR数据最佳模型性能为AUROC=0.88，当在癌症诊断前3个月内的疾病事件从训练机中排除时，AUROC（3m）减少至0.83，1000个年龄高于50岁的高风险人群估计相对风险为59。将丹麦模型交叉验证到US-VA中有较低的性能表现（AUROC=0.71），可以通过再训练来提高模型性能。这些结果说明为存在风险升高的患者设计现实监督计划的能力，通过早期发现这种侵袭性的癌症可能有益于寿命以及生活质量。&lt;/p>
&lt;p>&lt;a href="https://www.nature.com/articles/s41591-023-02332-5" target="_blank" rel="noreferrer">A deep learning algorithm to predict risk of pancreatic cancer from disease trajectories | Nature Medicine&lt;/a>&lt;/p></description></item><item><title>医学人工智能周刊 #3</title><link>https://youngforever.tech/ai4h/20230521-ai4h@3/</link><pubDate>Sat, 20 May 2023 09:00:00 +0000</pubDate><guid>https://youngforever.tech/ai4h/20230521-ai4h@3/</guid><description>&lt;h1 id="医学影像分类的自监督学习系统综述以及实施指南" class="relative group">医学影像分类的自监督学习：系统综述以及实施指南 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%8c%bb%e5%ad%a6%e5%bd%b1%e5%83%8f%e5%88%86%e7%b1%bb%e7%9a%84%e8%87%aa%e7%9b%91%e7%9d%a3%e5%ad%a6%e4%b9%a0%e7%b3%bb%e7%bb%9f%e7%bb%bc%e8%bf%b0%e4%bb%a5%e5%8f%8a%e5%ae%9e%e6%96%bd%e6%8c%87%e5%8d%97" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h1>&lt;p>深度学习和计算机视觉的发展给医学影像分析提供了有前景的解决方案，有潜力提高医疗水平以及患者治疗效果。然而，训练深度学习模型的主流范式需要大量标注的训练数据，这对于医学影像数据管理既耗时又花费巨大。自监督学习有可能从丰富没有标签的医学数据集中学习有用的见解，为发展鲁棒性高的医学影像模型做出巨大贡献。本综述对不同自监督策略进行了描述，并对2012年到2022年间在PubMed、Scopus、ArXiv上发表的使用自监督学习进行医学影像分类对研究进行系统综述。我们综合了前期工作的知识，并且为未来&lt;strong>利用自监督学习建立医学影像分类模型对研究人员提供了实践指南&lt;/strong>。&lt;/p>
&lt;h2 id="自监督常见技术" class="relative group">自监督常见技术 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%87%aa%e7%9b%91%e7%9d%a3%e5%b8%b8%e8%a7%81%e6%8a%80%e6%9c%af" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;h3 id="内在关系" class="relative group">内在关系 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%86%85%e5%9c%a8%e5%85%b3%e7%b3%bb" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>在一些手工制定的任务上预训练模型，可以利用数据的内部结构，而无需获取额外的标签。例如图像相对关系、预测图像旋转角度。&lt;/p>
&lt;h3 id="生成模型" class="relative group">生成模型 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e7%94%9f%e6%88%90%e6%a8%a1%e5%9e%8b" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>生成模型随着传统的自编码器（AE）、变分编码器（VAE）和生成式对抗网络（GANs）出现而变得流行起来，能够学习训练数据的分布，从而重建原始输入或者创建新的合成数据实例。通过使用现成的数据作为目标，生成模型能在不需要显式标签的情况下被训练用于自动学习有用的隐含表征。&lt;/p>
&lt;h3 id="对比学习" class="relative group">对比学习 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%af%b9%e6%af%94%e5%ad%a6%e4%b9%a0" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>基于转化图像引起的变化不能改变图像语义的假设。针对相同图像不同的数据增强方法组成了所谓的正样本对，相对于该图像其他图片以及增强样本组成了负样本对。优化模型让正样本对在潜空间距离变小并与负样本距离变远。&lt;/p>
&lt;ul>
&lt;li>SimCLR&lt;/li>
&lt;li>MoCo&lt;/li>
&lt;/ul>
&lt;h3 id="自预测" class="relative group">自预测 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%87%aa%e9%a2%84%e6%b5%8b" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>自预测SSL是对部分输入进行掩码或增强，然后用没有变化的部分来重建原始输入。自预测SSL想法来源于自然语言处理领域掩码模型。&lt;/p>
&lt;h2 id="微调技术" class="relative group">微调技术 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%be%ae%e8%b0%83%e6%8a%80%e6%9c%af" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>主要有两种策略用于微调已被SSL预训练的模型。如果将任意的影像模型都看成编码器和分类器两部分。两种策略能被分为&lt;/p>
&lt;ul>
&lt;li>端到端的微调，所有权重都训练&lt;/li>
&lt;li>固定编码器提取特征，对分类器进行微调&lt;/li>
&lt;/ul>
&lt;h2 id="自监督医学影像实施指南" class="relative group">自监督医学影像实施指南 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%87%aa%e7%9b%91%e7%9d%a3%e5%8c%bb%e5%ad%a6%e5%bd%b1%e5%83%8f%e5%ae%9e%e6%96%bd%e6%8c%87%e5%8d%97" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>需要多种&lt;strong>自监督学习策略相互比较&lt;/strong>，现有研究很少进行比较而是有无自监督学习策略比较。&lt;/p>
&lt;p>在大型自然图像数据集中自监督预训练的模型也可以被利用到医学影像，但由于&lt;strong>医学影像的独特性&lt;/strong>，究竟能迁移多少有待研究。&lt;/p>
&lt;ul>
&lt;li>由于医学图像采集的标准化协议和人体解剖学的同质性，医学图像具有很高的类间视觉相似性，即不同类也很相似；&lt;/li>
&lt;li>在医学成像领域，感兴趣的语义很少是诸如解剖器官之类的对象，而是该器官或组织内是否存在病理异常。许多异常的特征是非常微妙和局部的视觉线索，这些线索可能会由于增强变得模糊或被掩盖；&lt;/li>
&lt;li>自预测型自监督学习方法所使用的随机掩码（通过移除有疾病或者异常的图像）可能改变医学影像的语义。&lt;/li>
&lt;/ul>
&lt;p>在&lt;strong>对比学习形成正样本对&lt;/strong>时应该探索更多策略，而不是使用相同图片的不同增强版本，比如通过临床信息的相似性来定义正样本对。&lt;/p>
&lt;p>在&lt;strong>自监督学习中引入多模态信息&lt;/strong>提高下游任务模型性能。&lt;/p>
&lt;p>&lt;a href="https://www.nature.com/articles/s41746-023-00811-0" target="_blank" rel="noreferrer">Self-supervised learning for medical image classification: a systematic review and implementation guidelines | npj Digital Medicine&lt;/a>&lt;/p></description></item><item><title>医学人工智能周刊 #2</title><link>https://youngforever.tech/ai4h/20230509-ai4h@2/</link><pubDate>Mon, 08 May 2023 15:00:00 +0000</pubDate><guid>https://youngforever.tech/ai4h/20230509-ai4h@2/</guid><description>&lt;h2 id="大型语言模型在医学和医学研究中的伦理问题" class="relative group">大型语言模型在医学和医学研究中的伦理问题 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%a4%a7%e5%9e%8b%e8%af%ad%e8%a8%80%e6%a8%a1%e5%9e%8b%e5%9c%a8%e5%8c%bb%e5%ad%a6%e5%92%8c%e5%8c%bb%e5%ad%a6%e7%a0%94%e7%a9%b6%e4%b8%ad%e7%9a%84%e4%bc%a6%e7%90%86%e9%97%ae%e9%a2%98" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>大型语言模型（LLM）是一种在大量文本数据中训练的深度学习模型，其目标是生成类似人类响应的新文本。2022年11月30日发布的基于大型语言模型的对话机器人ChatGPT（OpenAI, San Francisco, CA, USA），将大型语言模型推动到公众视野并且让数百万能够使用它进行试验。自从那时起，医学从业者和研究者就开始探索LLM的潜在应用，因为很多医学实践和研究都围绕着大量基于文本的任务，例如展示、发表、记录和报告。使用LLM来帮助和简化这些任务可以节约大量时间，让临床人员和研究者能进行其他工作。目前有许多在不同开发阶段的其他LLMs，包括BioGPT（MIT），LaMDA（Google），Sparrow（Deepmind AI），Pangu Alpha（Huawei），OPT-IML（Meta）以及Megataron Turing MLG（Nvidia）。一些新的变种，例如基于PubMed文献训练后专注于生物医学领域文本生产以及挖掘的BioGPT，可能对未来医学和医学研究有重大的影响。与任何新兴、颠覆式的技术一样，重要的是考虑使用中的伦理并优先考虑符合社会最佳利益的负责任和有益的应用。&lt;strong>本文从偏见、信任、责任人、公平性以及隐私探讨了LLM在医学实践和研究中关键的伦理问题&lt;/strong>。&lt;/p>
&lt;p>&lt;a href="https://www.thelancet.com/journals/landig/article/PIIS2589-7500%2823%2900083-3/fulltext" target="_blank" rel="noreferrer">Ethics of large language models in medicine and medical research - The Lancet Digital Health&lt;/a>&lt;/p>
&lt;h2 id="对可穿戴设备数据去隐私化是不是给我们一个虚假的安全感系统综述" class="relative group">对可穿戴设备数据去隐私化是不是给我们一个虚假的安全感？系统综述 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%af%b9%e5%8f%af%e7%a9%bf%e6%88%b4%e8%ae%be%e5%a4%87%e6%95%b0%e6%8d%ae%e5%8e%bb%e9%9a%90%e7%a7%81%e5%8c%96%e6%98%af%e4%b8%8d%e6%98%af%e7%bb%99%e6%88%91%e4%bb%ac%e4%b8%80%e4%b8%aa%e8%99%9a%e5%81%87%e7%9a%84%e5%ae%89%e5%85%a8%e6%84%9f%e7%b3%bb%e7%bb%9f%e7%bb%bc%e8%bf%b0" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>可穿戴设备让采集和分享个人数据变得更加容易，这篇系统综述调查来源于可穿戴设备的去隐私化数据是不是足以保护数据集中个体的隐私。通过文献综述，本文总结正确识别率约86%-100%，表明重新标识风险很高。（重新识别通常是将去标识化或者匿名的数据集与有标识化数据的数据集建立连接）而且，&lt;strong>只需要1-300秒记录数据就可以从通常被认为不能产生标识化信息的传感器数据例如ECG进行重新标识化&lt;/strong>。该发现提醒重新思考数据分享的方法，在促进研究创新过程中，同时保护个人隐私。&lt;/p>
&lt;p>&lt;a href="https://www.thelancet.com/journals/landig/article/PIIS2589-7500%2822%2900234-5/fulltext?rss=yes" target="_blank" rel="noreferrer">Does deidentification of data from wearable devices give us a false sense of security? A systematic review - The Lancet Digital Health&lt;/a>&lt;/p>
&lt;h2 id="特定时间和事件深度学习方法用于心肌灌注成像后个性化风险评估" class="relative group">特定时间和事件深度学习方法用于心肌灌注成像后个性化风险评估 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e7%89%b9%e5%ae%9a%e6%97%b6%e9%97%b4%e5%92%8c%e4%ba%8b%e4%bb%b6%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0%e6%96%b9%e6%b3%95%e7%94%a8%e4%ba%8e%e5%bf%83%e8%82%8c%e7%81%8c%e6%b3%a8%e6%88%90%e5%83%8f%e5%90%8e%e4%b8%aa%e6%80%a7%e5%8c%96%e9%a3%8e%e9%99%a9%e8%af%84%e4%bc%b0" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>心肌灌注成像（MPI）的标准临床解释已被证实对主要不良心血管事件（MACE）有预后价值。然而，对特定事件类型和时间间隔进行个性化预测具有挑战性。本文建立一个可解释的深度学习模型，该模型能够直接从MPI和15中临床特征中分别预测全因死亡、急性冠状动脉综合症和血管重建的特定时间风险。这种方法能将&lt;strong>个体事件概率表示为时间的函数并且关注特定患者和特定事件的风险解释&lt;/strong>，这可能有助于引起人们对可改变风险因素的关注。该模型使用了&lt;code>DeepHit&lt;/code>中架构以及修改后的损失函数，输出是一个3*131的2维矩阵分别代表了从0到每30天直到最长随访时间各事件发生的概率。&lt;/p>
&lt;p>&lt;a href="https://www.nature.com/articles/s41746-023-00806-x" target="_blank" rel="noreferrer">Time and event-specific deep learning for personalized risk assessment after cardiac perfusion imaging | npj Digital Medicine&lt;/a>&lt;/p>
&lt;h2 id="临床预测算法验证展望" class="relative group">临床预测算法验证展望 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e4%b8%b4%e5%ba%8a%e9%a2%84%e6%b5%8b%e7%ae%97%e6%b3%95%e9%aa%8c%e8%af%81%e5%b1%95%e6%9c%9b" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>临床预测算法的泛化性与临床实践应用十分相关。本文基于现有文献概述了三种类型的泛化性：时序，地理，和领域泛化，以及其目标、方法、利益相关方。&lt;/p>
&lt;p>
&lt;figure>&lt;img src="https://cdn.jsdelivr.net/gh/jmwyf/pichosting@master/generalizability.png" alt="" class="mx-auto my-0 rounded-md" />
&lt;/figure>
&lt;/p>
&lt;p>&lt;a href="https://www.nature.com/articles/s41746-023-00832-9" target="_blank" rel="noreferrer">Perspectives on validation of clinical predictive algorithms | npj Digital Medicine&lt;/a>&lt;/p></description></item><item><title>医学人工智能周刊 开刊</title><link>https://youngforever.tech/ai4h/20230501-ai4h@1/</link><pubDate>Mon, 01 May 2023 17:20:00 +0000</pubDate><guid>https://youngforever.tech/ai4h/20230501-ai4h@1/</guid><description>&lt;h2 id="通用医学人工智能的基础模型" class="relative group">通用医学人工智能的基础模型 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e9%80%9a%e7%94%a8%e5%8c%bb%e5%ad%a6%e4%ba%ba%e5%b7%a5%e6%99%ba%e8%83%bd%e7%9a%84%e5%9f%ba%e7%a1%80%e6%a8%a1%e5%9e%8b" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>高灵活性、可复用人工智能模型的异常快速发展可能会在医疗领域迎来新的能力。我们提出一种医学人工智能新范式，称之为通用医学人工智能（GMAI）。&lt;strong>GMAI有能力只用少量数据或者非特定任务标签数据来解决各种各样的任务&lt;/strong>。通过在大样本，多样性数据中进行自监督学习，GMAI能灵活地解释不同组合的医学模态，包括影像、电子病历、实验室检查结果、基因组学、图表或者是医学文本。模型会产生富有表现力的输出，包括能显示先进医学推理能力的自由文本解释，口头建议或者图像标注。在本文中我们给出了对于GMAI一系列潜在高影响力的应用，并列出了实现这些应用对应的技术和训练所必须的数据集。我们预计GMAI驱动的应用将挑战当前监管和验证医疗AI器械现有的策略，而且将会改变收集大型医学数据的做法。&lt;/p>
&lt;p>&lt;a href="https://www.nature.com/articles/s41586-023-05881-4" target="_blank" rel="noreferrer">Foundation models for generalist medical artificial intelligence | Nature&lt;/a>&lt;/p>
&lt;h2 id="商业医学数据集对医学研究和医疗健康算法的影响" class="relative group">商业医学数据集对医学研究和医疗健康算法的影响 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%95%86%e4%b8%9a%e5%8c%bb%e5%ad%a6%e6%95%b0%e6%8d%ae%e9%9b%86%e5%af%b9%e5%8c%bb%e5%ad%a6%e7%a0%94%e7%a9%b6%e5%92%8c%e5%8c%bb%e7%96%97%e5%81%a5%e5%ba%b7%e7%ae%97%e6%b3%95%e7%9a%84%e5%bd%b1%e5%93%8d" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>随着医疗保健行业进入由云数据存储、分布式计算和机器学习驱动的数字健康新时代，医疗保健数据已成为对私人和公共实体具有价值的优质商品。目前无论是来自工业界、学术界还是政府机构的卫生数据收集和分发框架都并不完善，无法让研究人员充分利用下游分析的能力。在这篇医学政策论文中，我们回顾了现有商业医学数据供应商的现状，特别强调了他们数据的来源、数据可重复性、泛化性的挑战以及数据售卖伦理方面的考虑。我们&lt;strong>主张使用可持续的方法来组织管理公开健康数据，从而让全球人口能够被纳入生物医学研究界&lt;/strong>。然而，为了全面实施这些方法，关键利益相关者应齐心协力来让医学数据集更容易获得、更全面和更具有代表性，同时平衡好被收集数据个人隐私以及权利。&lt;/p>
&lt;p>&lt;a href="https://www.thelancet.com/journals/landig/article/PIIS2589-7500%2823%2900025-0/fulltext" target="_blank" rel="noreferrer">The impact of commercial health datasets on medical research and health-care algorithms - The Lancet Digital Health&lt;/a>&lt;/p>
&lt;h2 id="用于检测早产儿视网膜病变的定制工程和无代码深度学习模型的开发和国际验证回顾性研究" class="relative group">用于检测早产儿视网膜病变的定制工程和无代码深度学习模型的开发和国际验证：回顾性研究 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e7%94%a8%e4%ba%8e%e6%a3%80%e6%b5%8b%e6%97%a9%e4%ba%a7%e5%84%bf%e8%a7%86%e7%bd%91%e8%86%9c%e7%97%85%e5%8f%98%e7%9a%84%e5%ae%9a%e5%88%b6%e5%b7%a5%e7%a8%8b%e5%92%8c%e6%97%a0%e4%bb%a3%e7%a0%81%e6%b7%b1%e5%ba%a6%e5%ad%a6%e4%b9%a0%e6%a8%a1%e5%9e%8b%e7%9a%84%e5%bc%80%e5%8f%91%e5%92%8c%e5%9b%bd%e9%99%85%e9%aa%8c%e8%af%81%e5%9b%9e%e9%a1%be%e6%80%a7%e7%a0%94%e7%a9%b6" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>早产儿视网膜病变（ROP）是儿童失明的主要原因，由儿科眼科医生通过间隔筛查进行诊断。然而，早产儿生存率的提高加上现有专家的稀缺，引起了人们对这种方法可持续性的担忧。我们的目标是在英国伦敦的种族多元化人群中开发定制、无代码的基于深度学习的分类器，用于附加病变检查（ROP 的标志），并在四个国家和三大洲的种族、地理和社会经济多样化人群中对其进行外部验证。&lt;strong>无代码深度学习不依赖于受过专业培训的数据科学家，因此对资源匮乏的医疗保健环境具有特别的潜在好处&lt;/strong>。&lt;/p>
&lt;p>&lt;a href="https://www.thelancet.com/journals/landig/article/PIIS2589-7500%2823%2900050-X/fulltext" target="_blank" rel="noreferrer">Development and international validation of custom-engineered and code-free deep-learning models for detection of plus disease in retinopathy of prematurity: a retrospective study - The Lancet Digital Health&lt;/a>&lt;/p>
&lt;h2 id="目前对基于人工智能的医疗设备临床研究是否足够全面以支持全面的健康技术评估系统综述" class="relative group">目前对基于人工智能的医疗设备临床研究是否足够全面，以支持全面的健康技术评估？系统综述 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e7%9b%ae%e5%89%8d%e5%af%b9%e5%9f%ba%e4%ba%8e%e4%ba%ba%e5%b7%a5%e6%99%ba%e8%83%bd%e7%9a%84%e5%8c%bb%e7%96%97%e8%ae%be%e5%a4%87%e4%b8%b4%e5%ba%8a%e7%a0%94%e7%a9%b6%e6%98%af%e5%90%a6%e8%b6%b3%e5%a4%9f%e5%85%a8%e9%9d%a2%e4%bb%a5%e6%94%af%e6%8c%81%e5%85%a8%e9%9d%a2%e7%9a%84%e5%81%a5%e5%ba%b7%e6%8a%80%e6%9c%af%e8%af%84%e4%bc%b0%e7%b3%bb%e7%bb%9f%e7%bb%bc%e8%bf%b0" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>基于人工智能的医疗设备（AI-based MDs）在医疗保健领域正在经历指数级增长。这项研究旨在调查目前评估人工智能的研究是否包含健康技术评价（HTA）机构进行HTA所需的信息。在讨论部分，从各个角色的角度分析，建议该从哪些方面进行改进AI-MD评价&lt;/p>
&lt;p>&lt;a href="https://www.sciencedirect.com/science/article/pii/S0933365723000611" target="_blank" rel="noreferrer">Are current clinical studies on artificial intelligence-based medical devices comprehensive enough to support a full health technology assessment? A systematic review - ScienceDirect&lt;/a>&lt;/p>
&lt;p>#medical-data&lt;/p></description></item><item><title>生存分析（一）</title><link>https://youngforever.tech/posts/20230401-survival-analysis/</link><pubDate>Thu, 30 Mar 2023 17:20:00 +0000</pubDate><guid>https://youngforever.tech/posts/20230401-survival-analysis/</guid><description>
&lt;script>
document.addEventListener("DOMContentLoaded", function() {
renderMathInElement(document.body, {
delimiters: [
{left: '$$', right: '$$', display: true},
{left: '$', right: '$', display: false},
{left: '\\(', right: '\\)', display: false},
{left: '\\[', right: '\\]', display: true}
],
throwOnError : false
});
});
&lt;/script>
&lt;h2 id="简介" class="relative group">简介 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e7%ae%80%e4%bb%8b" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>生存分析是将&lt;strong>观察的结局&lt;/strong>和&lt;strong>出现结局所经历的时间&lt;/strong>结合起来进行分析的一系列统计方法，常用于研究&lt;strong>影响因素&lt;/strong>与生存时间和结局的关系，预测不同因素水平&lt;strong>个体生存预测&lt;/strong>。&lt;/p>
&lt;p>因为跟时间相关，所以要定义要&lt;strong>事件起点&lt;/strong>，以及&lt;strong>事件终点&lt;/strong>。&lt;strong>生存时间&lt;/strong>T也可以根据事件起终点计算出来。&lt;/p>
&lt;p>由于有些事件无法被观测或者没有观察到，导致生存时间无法被记录的情况称为&lt;strong>删失&lt;/strong>。其中最为常见的情形称为右删失（right censoring，下图）&lt;/p>
&lt;ul>
&lt;li>右删失：对这样的病人我们只知道其生存时间要大于从试验开始到删失发生的时间。有多种原因可以导致右删失情况的出现，其中包括：(1)病人在某时间点上退出试验或失去随访信息；(2)病人在整个试验结束时事件还未发生；(3)病人由于毒性等原因停用被分派的药物或换用其它药物；(4)竞争风险事件的发生&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。
&lt;figure>&lt;img src="https://cdn.jsdelivr.net/gh/jmwyf/pichosting@master/Rcensor.jpg" alt="" class="mx-auto my-0 rounded-md" />
&lt;/figure>
&lt;/li>
&lt;li>左删失&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>：事件发生了，且发生时间在（0，t） ，但确切时间并不清楚。&lt;/li>
&lt;li>区间删失: 事件发生在一个已知的具体时间段内，但是并不知道具体时间。&lt;/li>
&lt;/ul>
&lt;h2 id="生存函数" class="relative group">生存函数 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e7%94%9f%e5%ad%98%e5%87%bd%e6%95%b0" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>生存函数$$S(t) = P(T&amp;gt;t)$$描述的是&lt;strong>事件发生时间大于时间点t的概率&lt;/strong>，理论上T是连续变量，那么生存函数是一个连续的递减函数，然而实际实验中T都是有限时间点的，所以连续曲线变成离散的。“若想用光滑曲线来连接就需要对随机变量T的分布做出假设的参数拟合法，而曲线一般不宜正好经过所有的红点 (那样会导致过度拟合而使得统计模型没有多大效用) ；若用非参数的阶梯函数来连接，那么曲线简单而唯一确定！”这也是为什么k-m曲线这么重要的原因。
&lt;figure>&lt;img src="https://cdn.jsdelivr.net/gh/jmwyf/pichosting@master/surivial.jpg" alt="" class="mx-auto my-0 rounded-md" />
&lt;/figure>
&lt;/p>
&lt;h2 id="风险函数" class="relative group">风险函数 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e9%a3%8e%e9%99%a9%e5%87%bd%e6%95%b0" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>风险函数的定义即在&lt;strong>t时刻发生事件的概率&lt;/strong>。$$h(t)=P(T=t|T\ge t)$$生存函数是可以看到是从1到0递减的，而风险函数没有固定的单调性，可以是常数风险、可以随时间变化，比如上升、下降、先下降后上升。&lt;/p>
&lt;p>假设生存时间T这个变量概率分布满足$f(t)$，累积分布$F(t)=P(T\le t)= \int_0^t f(t)dt$，可以看到生存函数$S(t)=1-F(t)$，两边求导数可得$$f(t)=-S&amp;rsquo;(t)$$
那么在t时刻发生事件的风险用极限的观点来看即在$t -&amp;gt; t+\Delta t$ 这个区间内发生事件的数量除以在t时刻剩下的总人数$$h(t)=\lim_{\Delta t \to 0}\frac{F(t+\Delta t)-F(t)}{\Delta t*S(t)}=\frac{f(t)}{S(t)}=\frac{-S&amp;rsquo;(t)}{S(t)}$$
$$h(t)=\frac{-S&amp;rsquo;(t)}{S(t)}=-\frac{\partial}{\partial y}log[S(t)]\tag1$$&lt;/p>
&lt;p>$$S(t)=exp[-\int_0^th(t)dt]\tag2$$
式1后面一个等式右边求偏微分等于等式左边，两边积分即式2。以上为风险函数与生存函数之间的关系&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>&lt;/p>
&lt;h2 id="kaplan-meier生存曲线" class="relative group">Kaplan-Meier生存曲线 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#kaplan-meier%e7%94%9f%e5%ad%98%e6%9b%b2%e7%ba%bf" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>K-M曲线是非参数估计生存函数的一种方法。&lt;/p>
&lt;p>如何绘制K-M生存曲线？
&lt;strong>临床原始资料&lt;/strong>一般如下：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>患者&lt;/th>
&lt;th>生存时间&lt;/th>
&lt;th>发生事件与否&lt;/th>
&lt;th>删失与否&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>a&lt;/td>
&lt;td>10&lt;/td>
&lt;td>0&lt;/td>
&lt;td>r&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>b&lt;/td>
&lt;td>28&lt;/td>
&lt;td>1&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>c&lt;/td>
&lt;td>30&lt;/td>
&lt;td>1&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>d&lt;/td>
&lt;td>2&lt;/td>
&lt;td>1&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>e&lt;/td>
&lt;td>7&lt;/td>
&lt;td>0&lt;/td>
&lt;td>r&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>假设是来分析患者生存分析，定义结局是死亡，最长实验观察时间是90天，&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>首先是判断删失数据，假设a和e患者分别出院，观察不到死亡结局，那么以上两个患者是删失数据。&lt;/p>
&lt;p>将资料整理成&lt;strong>生存概率随时间变化表格&lt;/strong>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>患者&lt;/th>
&lt;th>生存时间&lt;/th>
&lt;th>存活患者数n&lt;/th>
&lt;th>死亡人数d&lt;/th>
&lt;th>当前存活概率(n-d)/n&lt;/th>
&lt;th>生存概率&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>d&lt;/td>
&lt;td>2&lt;/td>
&lt;td>5&lt;/td>
&lt;td>1&lt;/td>
&lt;td>4/5&lt;/td>
&lt;td>4/5&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>e&lt;/td>
&lt;td>7+&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>a&lt;/td>
&lt;td>10+&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;td>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>b&lt;/td>
&lt;td>28&lt;/td>
&lt;td>2&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1/2&lt;/td>
&lt;td>${4/5}*{1/2}=2/5$&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>c&lt;/td>
&lt;td>30&lt;/td>
&lt;td>1&lt;/td>
&lt;td>1&lt;/td>
&lt;td>0&lt;/td>
&lt;td>0&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>将上表生存时间以及生存概率可视化即可得到k-m曲线。&lt;/p>
&lt;p>以上介绍了生存分析的基本原理以及非参数生存分析K-M曲线是如何来的，有空介绍半参以及参数化的生存分析方法。&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>&lt;a href="https://m.thepaper.cn/baijiahao_19523218" target="_blank" rel="noreferrer">揭秘生存曲线背后的生物统计学&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>怎么理解生存分析的风险函数? - 数据的小米虫的回答 - 知乎 &lt;a href="https://www.zhihu.com/question/343779367/answer/2439383246" target="_blank" rel="noreferrer">https://www.zhihu.com/question/343779367/answer/2439383246&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>怎么理解生存分析的风险函数? - 郭老师医学统计的回答 - 知乎 &lt;a href="https://www.zhihu.com/question/343779367/answer/1493205766" target="_blank" rel="noreferrer">https://www.zhihu.com/question/343779367/answer/1493205766&lt;/a>&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>统计学中的假设检验</title><link>https://youngforever.tech/posts/20230323-hypothesis-testing/</link><pubDate>Wed, 22 Mar 2023 23:03:00 +0000</pubDate><guid>https://youngforever.tech/posts/20230323-hypothesis-testing/</guid><description>
&lt;script>
document.addEventListener("DOMContentLoaded", function() {
renderMathInElement(document.body, {
delimiters: [
{left: '$$', right: '$$', display: true},
{left: '$', right: '$', display: false},
{left: '\\(', right: '\\)', display: false},
{left: '\\[', right: '\\]', display: true}
],
throwOnError : false
});
});
&lt;/script>
&lt;h2 id="简介" class="relative group">简介 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e7%ae%80%e4%bb%8b" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>药厂宣传新药疗效很好，研究宣称研发的算法比之前的要好或者某项运动是有助于长寿的，我们怎么样来判断这些结果是否靠谱？这些问题就可以用统计学中的假设检验来判断。&lt;/p>
&lt;p>&lt;strong>统计推断&lt;/strong>是根据抽样分布规律和概率理论，由样本结果去推论总体特征。它主要包括假设检验和参数估计两个内容。&lt;/p>
&lt;p>假设检验的理论依据是“小概率事件原理”。“小概率事件原理”就是概率很小的事件在一次试验中认为是不可能发生的。如果预先的假设使得小概率事件发生了，类似于数学中传统推理的反证法出现逻辑矛盾那样，就认为出现了不合理现象，从而拒绝假设。一般把概率不超过0.10、0.05、0.01的事件当作“小概率事件”，称为检验水准或显著水平，通常取0.05、0.01，实际问题中也可取0.10、0.001等。&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/p>
&lt;h2 id="假设检验步骤" class="relative group">假设检验步骤 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%81%87%e8%ae%be%e6%a3%80%e9%aa%8c%e6%ad%a5%e9%aa%a4" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;h3 id="提出假设原假设和备择假设" class="relative group">提出假设原假设和备择假设 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%8f%90%e5%87%ba%e5%81%87%e8%ae%be%e5%8e%9f%e5%81%87%e8%ae%be%e5%92%8c%e5%a4%87%e6%8b%a9%e5%81%87%e8%ae%be" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>根据要比较的统计量类型，选择不同的假设检验类型，比如样本均值与指定值，汽车百公里油耗为xx；样本比例，支持率低于30%；样本方差，矿泉水容量的离散程度&lt;/li>
&lt;li>原假设通常是不存在差异或者没有关联，比如A组和B组均值没有差异；备选假设可以选择左右或双侧（大、小或不等于）
&lt;ul>
&lt;li>原假设是唯一的，而备择假设有很多，这也是为什么对无差异进行检验的原因，即&lt;strong>假设无差异为真来检验到底是不是无差异&lt;/strong>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="抽样optional" class="relative group">抽样（optional） &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%8a%bd%e6%a0%b7optional" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>一般问题就说了自己样本是什么。对于需要实验验证的问题，采样时由于不可能涵盖所有的样本，需要选择合适具有代表性的样本，进行两组比较或者与指定总体样本比较&lt;/li>
&lt;/ul>
&lt;h3 id="选择检验统计量" class="relative group">选择检验统计量 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e9%80%89%e6%8b%a9%e6%a3%80%e9%aa%8c%e7%bb%9f%e8%ae%a1%e9%87%8f" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>对假设进行检验的统计量，一般为抽样的样本在原假设情况下符合什么分布，计算对所关注差异或者效果的度量。&lt;/li>
&lt;/ul>
&lt;h3 id="统计显著性水平拒绝域临界点" class="relative group">统计显著性水平、拒绝域/临界点 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e7%bb%9f%e8%ae%a1%e6%98%be%e8%91%97%e6%80%a7%e6%b0%b4%e5%b9%b3%e6%8b%92%e7%bb%9d%e5%9f%9f%e4%b8%b4%e7%95%8c%e7%82%b9" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>&lt;strong>显著性水平&lt;/strong>：原假设为真时拒绝原假设的概率，一般是0.05。后续计算以原假设为真统计量出现的概率，假如小于显著性水平，即认为出现的概率很低（小概率事件），拒绝原假设。&lt;strong>假如原假设确实为真，这里就犯了第一类错误，但是这个概率是我们可以直接设置的。&lt;/strong>
&lt;ul>
&lt;li>&lt;strong>第一类错误&lt;/strong>&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>：没差异判断有差异$\alpha$&lt;/li>
&lt;li>&lt;strong>第二类错误&lt;/strong>：有差异判断没差异$\beta$&lt;/li>
&lt;li>统计检验能力：有差异能判断出差异，$1-\beta$ 通常需要大雨0.8（Jacob Cohen）&lt;/li>
&lt;li>第一类错误和第二类错误的关系
&lt;ul>
&lt;li>如下图应该选择备择假设，而选了null假设的概率为$\beta$, 可以看到$\alpha$越小，$\beta$越大,无法设置让第一类错误和第二类错误同时变小&lt;/li>
&lt;li>
&lt;figure>&lt;img src="https://cdn.jsdelivr.net/gh/jmwyf/pichosting@master/error1.png" alt="" class="mx-auto my-0 rounded-md" />
&lt;/figure>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>拒绝域：根据分布以及显著性水平可以确定拒绝域值&lt;/li>
&lt;/ul>
&lt;h3 id="求出检查统计量的p值" class="relative group">求出检查统计量的p值 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%b1%82%e5%87%ba%e6%a3%80%e6%9f%a5%e7%bb%9f%e8%ae%a1%e9%87%8f%e7%9a%84p%e5%80%bc" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>双边或单边某中分布下检验量统计量出现的概率&lt;/li>
&lt;/ul>
&lt;h3 id="查看样本结果是否位于拒绝域" class="relative group">查看样本结果是否位于拒绝域 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%9f%a5%e7%9c%8b%e6%a0%b7%e6%9c%ac%e7%bb%93%e6%9e%9c%e6%98%af%e5%90%a6%e4%bd%8d%e4%ba%8e%e6%8b%92%e7%bb%9d%e5%9f%9f" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>一般通过p与显著性水平比较&lt;/li>
&lt;/ul>
&lt;h3 id="决定是否接受原假设" class="relative group">决定是否接受原假设 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%86%b3%e5%ae%9a%e6%98%af%e5%90%a6%e6%8e%a5%e5%8f%97%e5%8e%9f%e5%81%87%e8%ae%be" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>如果p小于显著性水平，拒绝原假设&lt;/li>
&lt;/ul>
&lt;h2 id="案例一-女士品茶" class="relative group">案例一 女士品茶 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%a1%88%e4%be%8b%e4%b8%80-%e5%a5%b3%e5%a3%ab%e5%93%81%e8%8c%b6" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>以女士品茶为例，一位女士宣称自己可以分辨先奶后茶还是先茶后奶，大家都觉得不可思议，准备了10杯奶茶让其分辨，正确分辨了每一杯，现在问题是是不是真的能分辨？&lt;/p>
&lt;ul>
&lt;li>提出原假设和备择假设
&lt;ul>
&lt;li>原假设：不能分辨&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>选择检验统计量
&lt;ul>
&lt;li>在不能分辨的情况10次都对，对该事件的度量&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>显著性水平
&lt;ul>
&lt;li>0.05&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>检验统计量概率：不能分辨就是瞎猜每次判断的概率为1/2 ，该次事件的概率为$(\frac{1}{2})^{10}$&lt;/li>
&lt;li>判断是否位于拒绝域
&lt;ul>
&lt;li>远小于显著性水平，落在拒绝域，小概率事件不可能发生，但是在这次实验中发生，说明原假设不对&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>拒绝原假设
&lt;ul>
&lt;li>即该女士有分辨奶茶先后的能力&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="案例二-均值检验" class="relative group">案例二 均值检验 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%a1%88%e4%be%8b%e4%ba%8c-%e5%9d%87%e5%80%bc%e6%a3%80%e9%aa%8c" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>测定土地PH值是否为7，进行了17次采样，采样结果mean = 6.676， sd= 0.455&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>&lt;/p>
&lt;ul>
&lt;li>提出原假设与备择假设
&lt;ul>
&lt;li>ph为7&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>选择检验统计量
&lt;ul>
&lt;li>大样本数据一般认为符合正态分布，正态分布的均值$$z=\frac{\bar{x}-\mu_{0}}{\sigma/\sqrt{n}}$$而总体标准差一般很难获取，这时一般用样本标准差来代替，样本统计量服从t分布，上述公式变为$$z=\frac{\bar{x}-\mu_{0}}{s/\sqrt{n}}$$样本的均值应满足上式&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>显著性水平
&lt;ul>
&lt;li>0.05&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>检验统计量概率
&lt;ul>
&lt;li>代入公式得t统计量为-2.9，查分布表找到概率为0.009&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>拒绝&lt;/li>
&lt;/ul>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>实验设计与统计分析&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>统计学图鉴&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>统计学习理论与方法&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>什么是科学问题？</title><link>https://youngforever.tech/posts/20230306-%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%91%E5%AD%A6%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 06 Mar 2023 15:58:00 +0000</pubDate><guid>https://youngforever.tech/posts/20230306-%E4%BB%80%E4%B9%88%E6%98%AF%E7%A7%91%E5%AD%A6%E9%97%AE%E9%A2%98/</guid><description>&lt;p>科学问题：地球人还未找到答案，且无法确定是否能找到答案的问题 ；&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;/p>
&lt;p>技术问题：实现某个现实已有功能的途径；&lt;/p>
&lt;p>工程问题：结合多个技术解决一个系统化现实问题的方案；&lt;/p>
&lt;p>（科学问题：我不知道；&lt;/p>
&lt;p>技术问题：我没想到；&lt;/p>
&lt;p>工程问题：我做不了；）&lt;/p>
&lt;p>参考新版世界前沿125个科学问题&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>&lt;/p>
&lt;h2 id="sjtu--science-125个科学问题2021年版本" class="relative group">&lt;strong>SJTU &amp;amp; Science 125个科学问题&lt;/strong>（2021年版本） &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#sjtu--science-125%e4%b8%aa%e7%a7%91%e5%ad%a6%e9%97%ae%e9%a2%982021%e5%b9%b4%e7%89%88%e6%9c%ac" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;h2 id="medicine--health-11" class="relative group">&lt;strong>Medicine &amp;amp; Health&lt;/strong> (11) &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#medicine--health-11" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>&lt;strong>医学与健康&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>Can we predict the next pandemic?&lt;/li>
&lt;/ol>
&lt;p>1.我们可以预测下一次流行病吗？&lt;/p>
&lt;ol start="2">
&lt;li>Will we ever find a cure for the common cold?&lt;/li>
&lt;/ol>
&lt;p>2.我们会找到治疗感冒的方法吗？&lt;/p>
&lt;ol start="3">
&lt;li>Can we design and manufacture medicines customized for individual people?&lt;/li>
&lt;/ol>
&lt;p>3.我们可以设计和制造出为个人定制的药物吗？&lt;/p>
&lt;ol start="4">
&lt;li>Can a human tissue or organ be fully regenerated?&lt;/li>
&lt;/ol>
&lt;p>4.人体组织或器官可以完全再生吗？&lt;/p>
&lt;ol start="5">
&lt;li>How is immune homeostasis maintained and regulated?&lt;/li>
&lt;/ol>
&lt;p>5.如何维持和调节免疫稳态？&lt;/p>
&lt;ol start="6">
&lt;li>Is there a scientific basis to the Meridian System in traditional Chinese medicine?&lt;/li>
&lt;/ol>
&lt;p>6.中医的经络系统有科学依据吗？&lt;/p>
&lt;ol start="7">
&lt;li>How will the next generation of vaccines be made?&lt;/li>
&lt;/ol>
&lt;p>7.下一代疫苗将如何生产？&lt;/p>
&lt;ol start="8">
&lt;li>Can we ever overcome antibiotic resistance?&lt;/li>
&lt;/ol>
&lt;p>8.我们能否克服抗生素耐药性？&lt;/p>
&lt;ol start="9">
&lt;li>What is the etiology of autism?&lt;/li>
&lt;/ol>
&lt;p>9.自闭症的病因是什么？&lt;/p>
&lt;ol start="10">
&lt;li>What role does our microbiome play in health and disease?&lt;/li>
&lt;/ol>
&lt;p>10.我们的微生物组在健康和疾病中扮演什么角色？&lt;/p>
&lt;ol start="11">
&lt;li>Can xenotransplantation solve the shortage of donor organs?&lt;/li>
&lt;/ol>
&lt;p>11.异种移植能否解决供体器官的短缺问题？&lt;/p>
&lt;h2 id="biology22" class="relative group">&lt;strong>Biology&lt;/strong>(22) &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#biology22" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>&lt;strong>生命科学&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>What could help conservation of the oceans?&lt;/li>
&lt;/ol>
&lt;p>1.什么可以帮助保护海洋？&lt;/p>
&lt;ol start="2">
&lt;li>Can we stop ourselves from aging?&lt;/li>
&lt;/ol>
&lt;p>2.我们可以阻止自己衰老吗？&lt;/p>
&lt;ol start="3">
&lt;li>Why can only some cells become other cells?&lt;/li>
&lt;/ol>
&lt;p>3.为什么只有一些细胞会变成其他细胞？&lt;/p>
&lt;ol start="4">
&lt;li>Why are some genomes so big and others very small?&lt;/li>
&lt;/ol>
&lt;p>4.为什么有些基因组非常大而另一些却很小？&lt;/p>
&lt;ol start="5">
&lt;li>Will it be possible to cure all cancers?&lt;/li>
&lt;/ol>
&lt;p>5.有可能治愈所有癌症吗？&lt;/p>
&lt;ol start="6">
&lt;li>What genes make us uniquely human?&lt;/li>
&lt;/ol>
&lt;p>6.哪些基因使我们人类与众不同？&lt;/p>
&lt;ol start="7">
&lt;li>How do migratory animals know where they&amp;rsquo;re going?&lt;/li>
&lt;/ol>
&lt;p>7.迁徙动物如何知道它们要去哪里？&lt;/p>
&lt;ol start="8">
&lt;li>How many species are there on Earth?&lt;/li>
&lt;/ol>
&lt;p>8.地球上有多少物种？&lt;/p>
&lt;ol start="9">
&lt;li>How do organisms evolve?&lt;/li>
&lt;/ol>
&lt;p>9.有机体是如何进化的？&lt;/p>
&lt;ol start="10">
&lt;li>Why did dinosaurs grow to be so big?&lt;/li>
&lt;/ol>
&lt;p>10.为什么恐龙长得如此之大？&lt;/p>
&lt;ol start="11">
&lt;li>Did ancient humans interbreed with other human-like ancestors?&lt;/li>
&lt;/ol>
&lt;p>11.远古人类是否曾与其他类人祖先杂交？&lt;/p>
&lt;ol start="12">
&lt;li>Why do humans get so attached to dogs and cats?&lt;/li>
&lt;/ol>
&lt;p>12.人类为什么会对猫狗如此着迷？&lt;/p>
&lt;ol start="13">
&lt;li>Will the world&amp;rsquo;s population keep growing indefinitely?&lt;/li>
&lt;/ol>
&lt;p>13.世界人口会无限增长吗？&lt;/p>
&lt;ol start="14">
&lt;li>Why do we stop growing?&lt;/li>
&lt;/ol>
&lt;p>14.我们为什么会停止生长？&lt;/p>
&lt;ol start="15">
&lt;li>Is de-extinction possible?&lt;/li>
&lt;/ol>
&lt;p>15.能否复活灭绝生物？&lt;/p>
&lt;ol start="16">
&lt;li>Can humans hibernate?&lt;/li>
&lt;/ol>
&lt;p>16.人类可以冬眠吗？&lt;/p>
&lt;ol start="17">
&lt;li>Where do human emotions originate?&lt;/li>
&lt;/ol>
&lt;p>17.人类的情感源于何处？&lt;/p>
&lt;ol start="18">
&lt;li>Will humans look physically different in the future?&lt;/li>
&lt;/ol>
&lt;p>18.未来人类的外貌会有所不同吗？&lt;/p>
&lt;ol start="19">
&lt;li>Why were there species explosions and mass extinction?&lt;/li>
&lt;/ol>
&lt;p>19.为什么会发生物种大爆发和大灭绝？&lt;/p>
&lt;ol start="20">
&lt;li>How might genome editing be used to cure disease?&lt;/li>
&lt;/ol>
&lt;p>20.基因组编辑将如何用于治疗疾病？&lt;/p>
&lt;ol start="21">
&lt;li>Can a cell be artificially synthesized?&lt;/li>
&lt;/ol>
&lt;p>21.可以人工合成细胞吗？&lt;/p>
&lt;ol start="22">
&lt;li>How are biomolecules organized in cells to function orderly and effectively?&lt;/li>
&lt;/ol>
&lt;p>22.细胞内的生物分子是如何组织从而有序有效发挥作用的？&lt;/p>
&lt;h2 id="information-science4" class="relative group">&lt;strong>Information Science&lt;/strong>(4) &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#information-science4" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>&lt;strong>信息科学&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>Is there an upper limit to computer processing speed?&lt;/li>
&lt;/ol>
&lt;p>1.计算机处理速度是否有上限？&lt;/p>
&lt;ol start="2">
&lt;li>Can AI replace a doctor?&lt;/li>
&lt;/ol>
&lt;p>2.AI可以代替医生吗？&lt;/p>
&lt;ol start="3">
&lt;li>Can topological quantum computing be realized?&lt;/li>
&lt;/ol>
&lt;p>3.拓扑量子计算可以实现吗？&lt;/p>
&lt;ol start="4">
&lt;li>Can DNA act as an information storage medium?&lt;/li>
&lt;/ol>
&lt;p>4.DNA可以用作信息存储介质吗？&lt;/p>
&lt;h2 id="neuroscience12" class="relative group">&lt;strong>Neuroscience&lt;/strong>(12) &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#neuroscience12" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>&lt;strong>神经科学&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>What are the coding principles embedded in neuronal spike trains?&lt;/li>
&lt;/ol>
&lt;p>1.神经元放电序列的编码准则是什么？&lt;/p>
&lt;ol start="2">
&lt;li>Where does consciousness lie?&lt;/li>
&lt;/ol>
&lt;p>2.意识存在于何处？&lt;/p>
&lt;ol start="3">
&lt;li>Can human memory be stored, manipulated, and transplanted digitally?&lt;/li>
&lt;/ol>
&lt;p>3.能否数字化地存储、操控和移植人类记忆？&lt;/p>
&lt;ol start="4">
&lt;li>Why do we need sleep?&lt;/li>
&lt;/ol>
&lt;p>4.为什么我们需要睡眠？&lt;/p>
&lt;ol start="5">
&lt;li>What is addiction and how does it work?&lt;/li>
&lt;/ol>
&lt;p>5.什么是成瘾？&lt;/p>
&lt;ol start="6">
&lt;li>Why do we fall in love?&lt;/li>
&lt;/ol>
&lt;p>6.为什么我们会坠入爱河？&lt;/p>
&lt;ol start="7">
&lt;li>How did speech evolve and what parts of the brain control it?&lt;/li>
&lt;/ol>
&lt;p>7.言语如何演变形成，大脑的哪些部分对其进行控制？&lt;/p>
&lt;ol start="8">
&lt;li>How smart are nonhuman animals?&lt;/li>
&lt;/ol>
&lt;p>8.除人类以外的其他动物有多聪明？&lt;/p>
&lt;ol start="9">
&lt;li>Why are most people right-handed?&lt;/li>
&lt;/ol>
&lt;p>9.为什么大多数人都是右撇子？&lt;/p>
&lt;ol start="10">
&lt;li>Can we cure neurodegenerative diseases?&lt;/li>
&lt;/ol>
&lt;p>10.我们可以治愈神经退行性疾病吗？&lt;/p>
&lt;ol start="11">
&lt;li>Is it possible to predict the future?&lt;/li>
&lt;/ol>
&lt;p>11.有可能预知未来吗？&lt;/p>
&lt;ol start="12">
&lt;li>Can we more effectively diagnose and treat complex mental disorders?&lt;/li>
&lt;/ol>
&lt;p>12.精神障碍能否有效诊断和治疗？&lt;/p>
&lt;h2 id="artificial-intelligence8" class="relative group">&lt;strong>Artificial Intelligence&lt;/strong>(8) &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#artificial-intelligence8" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>&lt;strong>人工智能&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>Will injectable, disease-fighting nanobots ever be a reality?&lt;/li>
&lt;/ol>
&lt;p>1.可注射的抗病纳米机器人会成为现实吗？&lt;/p>
&lt;ol start="2">
&lt;li>Will it be possible to create sentient robots?&lt;/li>
&lt;/ol>
&lt;p>2.是否有可能创建有感知力的机器人？&lt;/p>
&lt;ol start="3">
&lt;li>Is there a limit to human intelligence?&lt;/li>
&lt;/ol>
&lt;p>3.人类智力是否有极限？&lt;/p>
&lt;ol start="4">
&lt;li>Will artificial intelligence replace humans?&lt;/li>
&lt;/ol>
&lt;p>4.人工智能会取代人类吗？&lt;/p>
&lt;ol start="5">
&lt;li>How does group intelligence emerge?&lt;/li>
&lt;/ol>
&lt;p>5.群体智能是如何出现的？&lt;/p>
&lt;ol start="6">
&lt;li>Can robots or AIs have human creativity?&lt;/li>
&lt;/ol>
&lt;p>6.机器人或 AI 可以具有人类创造力吗？&lt;/p>
&lt;ol start="7">
&lt;li>Can quantum artificial intelligence imitate the human brain?&lt;/li>
&lt;/ol>
&lt;p>7.量子人工智能可以模仿人脑吗？&lt;/p>
&lt;ol start="8">
&lt;li>Could we integrate with computers to form a human-machine hybrid species?&lt;/li>
&lt;/ol>
&lt;p>8.我们可以和计算机结合以形成人机混合物种吗？&lt;/p>
&lt;h2 id="mathematical-sciences3" class="relative group">&lt;strong>Mathematical Sciences&lt;/strong>(3) &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#mathematical-sciences3" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>&lt;strong>数学&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>What makes prime numbers so special?&lt;/li>
&lt;/ol>
&lt;p>1.什么使素数如此特别？&lt;/p>
&lt;ol start="2">
&lt;li>Will the Navier–Stokes problem ever be solved?&lt;/li>
&lt;/ol>
&lt;p>2.纳维尔-斯托克斯问题会得到解决吗？&lt;/p>
&lt;ol start="3">
&lt;li>Is the Riemann hypothesis true?&lt;/li>
&lt;/ol>
&lt;p>3.黎曼猜想是真的吗？&lt;/p>
&lt;h2 id="chemistry9" class="relative group">&lt;strong>Chemistry&lt;/strong>(9) &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#chemistry9" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>&lt;strong>化学&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>Are there more color pigments to discover?&lt;/li>
&lt;/ol>
&lt;p>1.还有更多色彩元素可发现吗？&lt;/p>
&lt;ol start="2">
&lt;li>Will the periodic table ever be complete?&lt;/li>
&lt;/ol>
&lt;p>2.元素周期表会完整吗？&lt;/p>
&lt;ol start="3">
&lt;li>How can we measure interface phenomena on the microscopic level?&lt;/li>
&lt;/ol>
&lt;p>3.如何在微观层面测量界面现象？&lt;/p>
&lt;ol start="4">
&lt;li>What is the future for energy storage？&lt;/li>
&lt;/ol>
&lt;p>4.能量存储的未来是怎样的？&lt;/p>
&lt;ol start="5">
&lt;li>Why does life require chirality?&lt;/li>
&lt;/ol>
&lt;p>5.为什么生命需要手性？&lt;/p>
&lt;ol start="6">
&lt;li>How can we better manage the world&amp;rsquo;s plastic waste?&lt;/li>
&lt;/ol>
&lt;p>6.我们如何更好地管理世界上的塑料废物？&lt;/p>
&lt;ol start="7">
&lt;li>Will AI redefine the future of chemistry?&lt;/li>
&lt;/ol>
&lt;p>7.AI会重新定义化学的未来吗？&lt;/p>
&lt;ol start="8">
&lt;li>How can matter be programmed into living materials?&lt;/li>
&lt;/ol>
&lt;p>8.物质如何被编码而成为生命材料？&lt;/p>
&lt;ol start="9">
&lt;li>What drives reproduction in living systems?&lt;/li>
&lt;/ol>
&lt;p>9.是什么驱动生命系统的复制？&lt;/p>
&lt;h2 id="astronomy23" class="relative group">&lt;strong>Astronomy&lt;/strong>(23) &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#astronomy23" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>&lt;strong>天文学&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>How many dimensions are there in space?&lt;/li>
&lt;/ol>
&lt;p>1.空间中有多少个维度？&lt;/p>
&lt;ol start="2">
&lt;li>What is the shape of the universe?&lt;/li>
&lt;/ol>
&lt;p>2.宇宙的形状是怎样的？&lt;/p>
&lt;ol start="3">
&lt;li>Where did the big bang start?&lt;/li>
&lt;/ol>
&lt;p>3.大爆炸从何处开始？&lt;/p>
&lt;ol start="4">
&lt;li>Why don&amp;rsquo;t the orbits of planets decay and cause them to crash into each other?&lt;/li>
&lt;/ol>
&lt;p>4.为什么行星的轨道不衰减并导致它们相互碰撞？&lt;/p>
&lt;ol start="5">
&lt;li>When will the universe die? Will it continue to expand?&lt;/li>
&lt;/ol>
&lt;p>5.宇宙何时消亡？它会继续膨胀吗？&lt;/p>
&lt;ol start="6">
&lt;li>Is it possible to live permanently on another planet?&lt;/li>
&lt;/ol>
&lt;p>6.我们有可能在另一个星球上长期居住吗？&lt;/p>
&lt;ol start="7">
&lt;li>Why do black holes exist?&lt;/li>
&lt;/ol>
&lt;p>7.为什么存在黑洞？&lt;/p>
&lt;ol start="8">
&lt;li>What is the universe made of?&lt;/li>
&lt;/ol>
&lt;p>8.宇宙是由什么构成的？&lt;/p>
&lt;ol start="9">
&lt;li>Are we alone in the universe?&lt;/li>
&lt;/ol>
&lt;p>9.我们是宇宙中唯一的生命体吗？&lt;/p>
&lt;ol start="10">
&lt;li>What is the origin of cosmic rays?&lt;/li>
&lt;/ol>
&lt;p>10.宇宙射线的起源是什么？&lt;/p>
&lt;ol start="11">
&lt;li>What is the origin of mass?&lt;/li>
&lt;/ol>
&lt;p>11.物质的起源是什么？&lt;/p>
&lt;ol start="12">
&lt;li>What is the smallest scale of space-time?&lt;/li>
&lt;/ol>
&lt;p>12.时空的最小尺度是是多少？&lt;/p>
&lt;ol start="13">
&lt;li>Is water necessary for all life in the universe, or just on Earth?&lt;/li>
&lt;/ol>
&lt;p>13.水是宇宙中所有生命所必需的么，还是仅对地球生命？&lt;/p>
&lt;ol start="14">
&lt;li>What is preventing humans from carrying out deep-space exploration?&lt;/li>
&lt;/ol>
&lt;p>14.是什么阻止了人类进行深空探测？&lt;/p>
&lt;ol start="15">
&lt;li>Is Einstein&amp;rsquo;s general theory of relativity correct?&lt;/li>
&lt;/ol>
&lt;p>15.爱因斯坦的广义相对论是正确的吗？&lt;/p>
&lt;ol start="16">
&lt;li>How are pulsars formed?&lt;/li>
&lt;/ol>
&lt;p>16.脉冲星是如何形成的？&lt;/p>
&lt;ol start="17">
&lt;li>Is our Milky Way Galaxy special?&lt;/li>
&lt;/ol>
&lt;p>17.我们的银河系特别吗？&lt;/p>
&lt;ol start="18">
&lt;li>What is the volume, composition, and significance of the deep biosphere?&lt;/li>
&lt;/ol>
&lt;p>18.深层生物圈的规模、组成和意义是什么？&lt;/p>
&lt;ol start="19">
&lt;li>Will humans one day have to leave the planet (or die trying)?&lt;/li>
&lt;/ol>
&lt;p>19.人类有一天会不得不离开地球吗（还是会在尝试中死去）？&lt;/p>
&lt;ol start="20">
&lt;li>Where do the heavy elements in the universe come from?&lt;/li>
&lt;/ol>
&lt;p>20.宇宙中的重元素来自何处？&lt;/p>
&lt;ol start="21">
&lt;li>Is it possible to understand the structure of compact stars and matter?&lt;/li>
&lt;/ol>
&lt;p>21.有可能了解致密恒星和物质的结构吗？&lt;/p>
&lt;ol start="22">
&lt;li>What is the origin of the high-energy cosmic neutrinos?&lt;/li>
&lt;/ol>
&lt;p>22.高能宇宙中微子的起源是什么？&lt;/p>
&lt;ol start="23">
&lt;li>What is gravity?&lt;/li>
&lt;/ol>
&lt;p>23.什么是重力？&lt;/p>
&lt;h2 id="physics18" class="relative group">&lt;strong>Physics&lt;/strong>(18) &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#physics18" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>&lt;strong>物理学&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>Is there a diffraction limit?&lt;/li>
&lt;/ol>
&lt;p>1.有衍射极限吗？&lt;/p>
&lt;ol start="2">
&lt;li>What is the microscopic mechanism for high-temperature superconductivity?&lt;/li>
&lt;/ol>
&lt;p>2.高温超导的微观机理是什么？&lt;/p>
&lt;ol start="3">
&lt;li>What are the limits of heat transfer in matter?&lt;/li>
&lt;/ol>
&lt;p>3.物质传热的极限是什么？&lt;/p>
&lt;ol start="4">
&lt;li>What are the fundamental principles of collective motion?&lt;/li>
&lt;/ol>
&lt;p>4.集体运动的基本原理是什么？&lt;/p>
&lt;ol start="5">
&lt;li>What are the smallest building blocks of matter?&lt;/li>
&lt;/ol>
&lt;p>5.什么是物质的最小组成部分？&lt;/p>
&lt;ol start="6">
&lt;li>Will we ever travel at the speed of light?&lt;/li>
&lt;/ol>
&lt;p>6.我们会以光速行驶吗？&lt;/p>
&lt;ol start="7">
&lt;li>What is quantum uncertainty and why is it important?&lt;/li>
&lt;/ol>
&lt;p>7.什么是量子不确定性，为什么它很重要？&lt;/p>
&lt;ol start="8">
&lt;li>Will there ever be a &amp;ldquo;theory of everything&amp;rdquo;?&lt;/li>
&lt;/ol>
&lt;p>8.会有“万有理论”吗？&lt;/p>
&lt;ol start="9">
&lt;li>Why does time seem to flow in only one direction?&lt;/li>
&lt;/ol>
&lt;p>9.为什么时间似乎只朝一个方向流动？&lt;/p>
&lt;ol start="10">
&lt;li>What is dark matter?&lt;/li>
&lt;/ol>
&lt;p>10.什么是暗物质？&lt;/p>
&lt;ol start="11">
&lt;li>Can we make a real, human-size invisibility cloak?&lt;/li>
&lt;/ol>
&lt;p>11.我们可以制作出真人大小的隐形斗篷吗？&lt;/p>
&lt;ol start="12">
&lt;li>Are there any particles that behave oppositely to the properties or states of photons?&lt;/li>
&lt;/ol>
&lt;p>12.是否存在与光子性质或状态相反的粒子？&lt;/p>
&lt;ol start="13">
&lt;li>Will the Bose-Einstein condensate be widely used in the future?&lt;/li>
&lt;/ol>
&lt;p>13.玻色-爱因斯坦冷凝体未来会被广泛使用吗？&lt;/p>
&lt;ol start="14">
&lt;li>Can humans make intense lasers with incoherence comparable to sunlight?&lt;/li>
&lt;/ol>
&lt;p>14.人类能制造出与太阳光相似的非相干强激光吗？&lt;/p>
&lt;ol start="15">
&lt;li>What is the maximum speed to which we can accelerate a particle?&lt;/li>
&lt;/ol>
&lt;p>15.我们最多可以将粒子加速到多快？&lt;/p>
&lt;ol start="16">
&lt;li>Is quantum many-body entanglement more fundamental than quantum fields?&lt;/li>
&lt;/ol>
&lt;p>16.量子多体纠缠比量子场更基本吗？&lt;/p>
&lt;ol start="17">
&lt;li>What is the optimum hardware for quantum computers?&lt;/li>
&lt;/ol>
&lt;p>17.量子计算机的最佳硬件是什么？&lt;/p>
&lt;ol start="18">
&lt;li>Can we accurately simulate the macro- and microworld?&lt;/li>
&lt;/ol>
&lt;p>18.我们可以精确模拟宏观和微观世界吗？&lt;/p>
&lt;h2 id="engineering--material-science4" class="relative group">&lt;strong>Engineering &amp;amp; Material Science&lt;/strong>(4) &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#engineering--material-science4" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>&lt;strong>工程与材料科学&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>What is the ultimate statistical invariances of turbulence?&lt;/li>
&lt;/ol>
&lt;p>1.湍流的最终统计不变性是什么？&lt;/p>
&lt;ol start="2">
&lt;li>How can we break the current limit of energy conversion efficiencies?&lt;/li>
&lt;/ol>
&lt;p>2.我们如何突破当前的能量转换效率极限？&lt;/p>
&lt;ol start="3">
&lt;li>How can we develop manufacturing systems on Mars?&lt;/li>
&lt;/ol>
&lt;p>3.我们如何在火星上开发制造系统？&lt;/p>
&lt;ol start="4">
&lt;li>Is a future of only self-driving cars realistic?&lt;/li>
&lt;/ol>
&lt;p>4.纯无人驾驶汽车的未来是否现实？&lt;/p>
&lt;h2 id="ecology8" class="relative group">&lt;strong>Ecology&lt;/strong>(8) &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#ecology8" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>&lt;strong>生态学&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>Can we stop global climate change?&lt;/li>
&lt;/ol>
&lt;p>1.我们可以阻止全球气候变化吗？&lt;/p>
&lt;ol start="2">
&lt;li>Where do we put all the excess carbon dioxide?&lt;/li>
&lt;/ol>
&lt;p>2.我们能把过量的二氧化碳存到何处？&lt;/p>
&lt;ol start="3">
&lt;li>What creates the Earth&amp;rsquo;s magnetic field (and why does it move)?&lt;/li>
&lt;/ol>
&lt;p>3.是什么创造了地球的磁场（为什么它会移动）？&lt;/p>
&lt;ol start="4">
&lt;li>Will we be able to predict catastrophic weather events (tsunami, hurricanes, earthquakes) more accurately?&lt;/li>
&lt;/ol>
&lt;p>4.我们是否能够更准确地预测灾害性事件（海啸、飓风、地震）？&lt;/p>
&lt;ol start="5">
&lt;li>What happens if all the ice on the planet melts?&lt;/li>
&lt;/ol>
&lt;p>5.如果地球上所有的冰融化会怎样？&lt;/p>
&lt;ol start="6">
&lt;li>Can we create an environmentally friendly replacement for plastics?&lt;/li>
&lt;/ol>
&lt;p>6.我们可以创造一种环保的塑料替代品吗？&lt;/p>
&lt;ol start="7">
&lt;li>Can we achieve a situation where essentially every material can be recycled and reused?&lt;/li>
&lt;/ol>
&lt;p>7.几乎所有材料都可以回收再利用是否可以实现？&lt;/p>
&lt;ol start="8">
&lt;li>Will we soon see the end of monocultures like wheat, maize, rice, and soy?&lt;/li>
&lt;/ol>
&lt;p>8.我们会很快看到小麦、玉米、大米和大豆等单一作物的终结吗？&lt;/p>
&lt;h2 id="energy-science3" class="relative group">&lt;strong>Energy Science&lt;/strong>(3) &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#energy-science3" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>&lt;strong>能源科学&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>Could we live in a fossil-fuel-free world?&lt;/li>
&lt;/ol>
&lt;p>1.我们可以生活在一个去化石燃料的世界中吗？&lt;/p>
&lt;ol start="2">
&lt;li>What is the future of hydrogen energy?&lt;/li>
&lt;/ol>
&lt;p>2.氢能的未来是怎样的？&lt;/p>
&lt;ol start="3">
&lt;li>Will cold fusion ever be possible?&lt;/li>
&lt;/ol>
&lt;p>3.冷聚变有可能实现吗？&lt;/p>
&lt;h2 id="思考" class="relative group">思考 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%80%9d%e8%80%83" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>科学问题有大有小，上面是全人类目前这个阶段关注的大科学问题，那么小而精的科学问题该如何凝练？&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>&lt;a href="https://www.bilibili.com/video/av887401991/" target="_blank" rel="noreferrer">【复旦赵斌】避免尴尬，教你一句话说清楚什么是科学问题、技术问题和工程问题_哔哩哔哩_bilibili&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>&lt;a href="https://www.bilibili.com/video/BV1oh411q7op/?spm_id_from=pageDriver" target="_blank" rel="noreferrer">【复旦赵斌】老师喊你搞事情 | 125个科学问题，你最想了解哪个？_哔哩哔哩_bilibili&lt;/a>c&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>&lt;a href="https://mp.weixin.qq.com/s/HrV3AVJ5PqdUZVzUPxCxQw" target="_blank" rel="noreferrer">全世界最前沿的125个科学问题！&lt;/a>&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>MultiBench多模态表征学习的多尺度基准</title><link>https://youngforever.tech/posts/20230304-multibench/</link><pubDate>Sat, 04 Mar 2023 15:17:00 +0000</pubDate><guid>https://youngforever.tech/posts/20230304-multibench/</guid><description>&lt;p>MULTIBENCH，一个系统而统一的大规模多模态学习基准，涵盖15个数据集、10种模式、20个预测任务和6个研究领域&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>。&lt;/p>
&lt;h2 id="引言" class="relative group">引言 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%bc%95%e8%a8%80" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>背景：&lt;/p>
&lt;ul>
&lt;li>语言和视觉领域多模态学习发展不错，但是其他领域欠缺&lt;/li>
&lt;li>现在的基准评价关注性能，没有量化缺点包括时间空间复杂度，由于不完美模态导致的鲁棒性降低，需要在性能、鲁棒性、复杂度取得平衡&lt;/li>
&lt;/ul>
&lt;p>提出multibench就是解决以上问题：&lt;/p>
&lt;ul>
&lt;li>扩充收集各领域数据集、数据模态&lt;/li>
&lt;li>量化复杂度&lt;/li>
&lt;li>提出标准流程评价对噪声和缺失模态情况下的鲁棒性&lt;/li>
&lt;/ul>
&lt;p>MultiBench是一个端到端的过程，包括数据预处理、数据集拆分、多模态算法、评估指标和交叉验证。&lt;/p>
&lt;ul>
&lt;li>开发工具包MultiZoo&lt;/li>
&lt;li>可以用于workshop、教学等&lt;/li>
&lt;/ul>
&lt;h2 id="多尺度多模态基准" class="relative group">多尺度多模态基准 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%a4%9a%e5%b0%ba%e5%ba%a6%e5%a4%9a%e6%a8%a1%e6%80%81%e5%9f%ba%e5%87%86" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>第一版集中在多模态融合，对于多模态翻译等问题未来版本可能涉及&lt;/p>
&lt;h3 id="数据集" class="relative group">数据集 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%95%b0%e6%8d%ae%e9%9b%86" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>介绍了6大领域15个数据集，表1&lt;/p>
&lt;ul>
&lt;li>情感计算（affective computing）&lt;/li>
&lt;li>医疗：时变和静态变量的整合使用&lt;/li>
&lt;li>机器人&lt;/li>
&lt;li>金融&lt;/li>
&lt;li>人机交互&lt;/li>
&lt;li>多媒体
&lt;figure>&lt;img src="https://cdn.jsdelivr.net/gh/jmwyf/pichosting@master/multibenchdata.png" alt="" class="mx-auto my-0 rounded-md" />
&lt;/figure>
&lt;/li>
&lt;/ul>
&lt;h3 id="评价标准" class="relative group">评价标准 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%af%84%e4%bb%b7%e6%a0%87%e5%87%86" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>性能：&lt;/p>
&lt;ul>
&lt;li>regression: MSE, MAE,&lt;/li>
&lt;li>classification: F1-score, AUPRC&lt;/li>
&lt;/ul>
&lt;p>复杂度：&lt;/p>
&lt;ul>
&lt;li>data size in bits&lt;/li>
&lt;li>number of model parameters&lt;/li>
&lt;li>time and memory resources on CPU and GPU&lt;/li>
&lt;/ul>
&lt;p>鲁棒性：&lt;/p>
&lt;ul>
&lt;li>单模态独有噪音：对图像、音频等单独处理&lt;/li>
&lt;li>考虑多模态整体的不完善：比如缺失模态等&lt;/li>
&lt;/ul>
&lt;h2 id="multizoo多模态算法集合" class="relative group">MultiZoo：多模态算法集合 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#multizoo%e5%a4%9a%e6%a8%a1%e6%80%81%e7%ae%97%e6%b3%95%e9%9b%86%e5%90%88" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>涵盖实现multibench整个过程中的算法&lt;/p>
&lt;h3 id="数据预处理" class="relative group">数据预处理 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%95%b0%e6%8d%ae%e9%a2%84%e5%a4%84%e7%90%86" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>WordAlign算法
&lt;ul>
&lt;li>将各模态信息调整到统一粒度&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="融合范式" class="relative group">融合范式 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%9e%8d%e5%90%88%e8%8c%83%e5%bc%8f" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>早期和晚期融合
&lt;ul>
&lt;li>EF，LF&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>多模态张量: 多模态互补
&lt;ul>
&lt;li>Tensor Fusion&lt;/li>
&lt;li>Low-rank Tensor Fusion&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>多模态乘法交互: 多模态交互
&lt;ul>
&lt;li>MI-MATRIX&lt;/li>
&lt;li>MI-VECTOR&lt;/li>
&lt;li>MI-SCALAR&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>多模态门控
&lt;ul>
&lt;li>NL GATE: 自注意力机制&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>时序注意力模型
&lt;ul>
&lt;li>MULT: 多模态Transformer&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>网络架构搜索
&lt;ul>
&lt;li>MFAS&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="优化目标" class="relative group">优化目标 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e4%bc%98%e5%8c%96%e7%9b%ae%e6%a0%87" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>除了标准的监督损失函数，纳入一些新提出的目标函数&lt;/p>
&lt;ul>
&lt;li>CCA&lt;/li>
&lt;li>REFNET&lt;/li>
&lt;li>MFM&lt;/li>
&lt;li>MCTN&lt;/li>
&lt;/ul>
&lt;h3 id="训练过程" class="relative group">训练过程 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%ae%ad%e7%bb%83%e8%bf%87%e7%a8%8b" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>Gradient Blending来计算融合的权重&lt;/li>
&lt;li>Regularization by Maximizing Functional Entropies&lt;/li>
&lt;/ul>
&lt;h2 id="实验" class="relative group">实验 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%ae%9e%e9%aa%8c" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ul>
&lt;li>泛化性能
&lt;ul>
&lt;li>目前的方法表现出高方差，没有放之四海而皆准的模型，特别是对于未被研究的模式和任务。&lt;/li>
&lt;li>后期融合表现比较均衡&lt;/li>
&lt;li>有些融合方法是专门为2模态设计，有些在2/3模态表现不好&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>单模态与多模态的权衡&lt;/li>
&lt;li>性能与复杂度的权衡&lt;/li>
&lt;li>性能与鲁棒性的权衡&lt;/li>
&lt;/ul>
&lt;h2 id="结论" class="relative group">结论 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e7%bb%93%e8%ae%ba" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>一个大规模的基准，统一了以前在多模态研究中互不相干的工作，重点是易用性、可及性和可重复性。&lt;/p>
&lt;h3 id="未来拓展" class="relative group">未来拓展 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%9c%aa%e6%9d%a5%e6%8b%93%e5%b1%95" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>其他的多模态问题&lt;/li>
&lt;li>新的评价指标&lt;/li>
&lt;li>多模态迁移学习或者协同学习&lt;/li>
&lt;li>多模态多任务学习&lt;/li>
&lt;/ul>
&lt;h2 id="思考" class="relative group">思考 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%80%9d%e8%80%83" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>MultiBench把以前多模态研究中使用的公开数据集，算法，评价指标等都统一在了一个框架下，期望标准化多模态学习过程，并且能将不同的算法模型在其他模态、任务中进行比较。大而全的框架确实能为各类多模态任务提供一个baseline，但是各专业领域内的多模态模型应该是存在一些差异的，就像我们很难期待一个医生能掌握律师干的事情，然而，人工智能的发展确实很快，比人还强大的通用人工智能应该也会实现。&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>Liang, P. P. et al. MultiBench: Multiscale Benchmarks for Multimodal Representation Learning. (2021) doi:10.48550/arXiv.2107.07502.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>ClinicalBERT: 对医学文本建模用于再入院预测</title><link>https://youngforever.tech/posts/20230302-clinicalbert/</link><pubDate>Wed, 01 Mar 2023 10:12:00 +0000</pubDate><guid>https://youngforever.tech/posts/20230302-clinicalbert/</guid><description>
&lt;script>
document.addEventListener("DOMContentLoaded", function() {
renderMathInElement(document.body, {
delimiters: [
{left: '$$', right: '$$', display: true},
{left: '$', right: '$', display: false},
{left: '\\(', right: '\\)', display: false},
{left: '\\[', right: '\\]', display: true}
],
throwOnError : false
});
});
&lt;/script>
&lt;p>使用临床文本预训练BERT然后在再入院任务中微调&lt;/p>
&lt;h2 id="引言" class="relative group">引言 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%bc%95%e8%a8%80" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>非结构化、高维稀疏信息例如临床文本难以在临床机器学习模型中使用。临床文本中包含什么样的临床价值？更加丰富、详细。然而重症监护室医生在有限时间内需要做出最优决策，读大量的临床文本，增加工作量。&lt;/p>
&lt;p>再入院会降低患者生活质量、增加花费。这篇文章旨在建立一个出院决策模型，根据医护人员笔记动态的赋予患者30天再入院的风险。&lt;/p>
&lt;h3 id="背景" class="relative group">背景 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%83%8c%e6%99%af" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>临床文本会有缩写、黑话、不标准的语法结构，从临床文本中学习有用的表征具有挑战。以往的方法无法捕捉获取临床意义的文本长程依赖，介绍BERT，以及基于BERT已经开展的工作，已经有人把BERT用在临床文本了，本文在再入院任务上评估改进ClinicalBERT并且在更长的序列上进行预训练。&lt;/p>
&lt;p>介绍前人在ICU再入院预测上的工作，缺点：大多数工作都只用了出院的信息，ClinicalBERT使用患者住院整个时间段信息。&lt;/p>
&lt;h3 id="该工作的重要性" class="relative group">该工作的重要性 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%af%a5%e5%b7%a5%e4%bd%9c%e7%9a%84%e9%87%8d%e8%a6%81%e6%80%a7" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>用出院信息来预测意味着减少了再入院风险的机会少了，都要出院了，此刻告诉有再入院的风险，难以采取措施；&lt;/li>
&lt;li>由于医院已经有很多误报警，医疗模型需要高的PPV&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>，该模型同其他模型相比有最高的recall&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>；&lt;/li>
&lt;li>模型中attention能用于可视化解释。&lt;/li>
&lt;/ul>
&lt;h2 id="方法" class="relative group">方法 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%96%b9%e6%b3%95" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;h3 id="什么是bert" class="relative group">什么是BERT &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e4%bb%80%e4%b9%88%e6%98%afbert" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>BERT是基于transformer编码器架构的深度神经网络，它用于学习文本的嵌入表达。&lt;/p>
&lt;ul>
&lt;li>自注意力机制&lt;/li>
&lt;li>BERT模型通过2个无监督任务进行预训练：掩码模型和下一个句子预测。&lt;/li>
&lt;/ul>
&lt;h3 id="临床文本嵌入" class="relative group">临床文本嵌入 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e4%b8%b4%e5%ba%8a%e6%96%87%e6%9c%ac%e5%b5%8c%e5%85%a5" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>先分词成token&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>，这里是子词粒度的tokenization&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>&lt;/li>
&lt;li>ClinicalBert的token包括子词、分段嵌入、位置嵌入相加后的结果
&lt;ul>
&lt;li>分段嵌入是当多个序列输入时，表示当前的token属于哪一段&lt;/li>
&lt;li>位置嵌入即在输入序列中token的位置&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="自注意力机制" class="relative group">自注意力机制 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%87%aa%e6%b3%a8%e6%84%8f%e5%8a%9b%e6%9c%ba%e5%88%b6" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>用于输入token之间的关系捕捉&lt;/p>
&lt;h3 id="预训练" class="relative group">预训练 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e9%a2%84%e8%ae%ad%e7%bb%83" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>BERT是在BooksCorpus和Wikipedia中预训练的，临床文本黑话缩写，与一般文本可能语法也不一样，需要在临床文本中进行预训练。损失函数是预测掩码单词任务和预测两个句子是否连续任务损失函数之和。&lt;/p>
&lt;h3 id="微调" class="relative group">微调 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%be%ae%e8%b0%83" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>在再入院任务中微调
$$P(readmit = 1 | h_{[cls]}) = \sigma(Wh_{[cls]})$$
式中W为参数，h为BERT模型输出。&lt;/p>
&lt;h2 id="实验" class="relative group">实验 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%ae%9e%e9%aa%8c" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;h3 id="数据" class="relative group">数据 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%95%b0%e6%8d%ae" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>MIMIC-III中2083180份去隐私化后的文本，五折每一轮其中四折预训练，最后一折微调&lt;/p>
&lt;h3 id="实证研究i" class="relative group">实证研究I &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%ae%9e%e8%af%81%e7%a0%94%e7%a9%b6i" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>在临床语言建模中ClinicalBERT与BERT进行比较：预测掩码token以及2个句子是否连续任务中均优于BERT&lt;/li>
&lt;li>定性分析：专家给出相似医学概念，ClinicalBERT学习嵌入表达后，进行降维可视化，发现相近&lt;/li>
&lt;li>定量分析：采用相似度度量公式计算表征之前相似度，然后与专家打分的相似度进行关联分析计算pearson相关系数&lt;/li>
&lt;/ul>
&lt;h3 id="实证研究ii" class="relative group">实证研究II &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%ae%9e%e8%af%81%e7%a0%94%e7%a9%b6ii" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>再入院队列：34560患者，2963再入院，42358负样本，&lt;em>这里为啥有这么多负样本？&lt;/em>&lt;/li>
&lt;li>调整后的再入院预测：
$$P(readmit = 1|h_{patient}) = \frac{P^n_{max}+P^n_{mean}n/c}{1+n/c}$$
&lt;ul>
&lt;li>有些文本是比较重要，有些文本对再入院预测不重要，所以要包括最大的概率&lt;/li>
&lt;li>噪声会降低性能，消除噪音的方法还是取大多数值的平均，如果序列越长，噪声出现的可能性越大，所以需要平均值的权重越大，引入了n/c作为比例因子&lt;/li>
&lt;li>分母则是用于概率归一化到0,1区间&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>评估指标
&lt;ul>
&lt;li>AUROC&lt;/li>
&lt;li>AUPRC&lt;/li>
&lt;li>RP80：准确度为80%时候到召回率&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>模型比较：Bag of words，BI-LSTM，BERT&lt;/li>
&lt;li>用出院记录来进行再入院预测&lt;/li>
&lt;li>用24-48小时数据预测，以及48-72小时数据预测&lt;/li>
&lt;li>可解释性
&lt;ul>
&lt;li>给出一句话的self-attention权重示意图&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="讨论" class="relative group">讨论 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%ae%a8%e8%ae%ba" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>建议在私有数据集上重新训练后在下游任务中使用&lt;/p>
&lt;h2 id="代码" class="relative group">代码 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e4%bb%a3%e7%a0%81" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ul>
&lt;li>源码：&lt;a href="https://github.com/kexinhuang12345/clinicalBERT" target="_blank" rel="noreferrer">GitHub - kexinhuang12345/clinicalBERT: ClinicalBERT: Modeling Clinical Notes and Predicting Hospital Readmission (CHIL 2020 Workshop)&lt;/a>&lt;/li>
&lt;li>模型：&lt;a href="https://huggingface.co/emilyalsentzer/Bio_ClinicalBERT" target="_blank" rel="noreferrer">emilyalsentzer/Bio_ClinicalBERT · Hugging Face&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="思考" class="relative group">思考 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%80%9d%e8%80%83" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>自chatgpt后，大型语言模型受到广泛关注，医学语言模型的发展似乎有多种路径，一种是直接在通用文本上预训练，一种是在医学文本中预训练，或是通用模型在领域微调，个人感觉应该是第三种效果会较好。&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>Huang, K., Altosaar, J. &amp;amp; Ranganath, R. ClinicalBERT: Modeling Clinical Notes and Predicting Hospital Readmission. in &lt;em>CHIL&lt;/em> (arXiv, 2020). doi:&lt;a href="https://doi.org/10.48550/arXiv.1904.05342" target="_blank" rel="noreferrer">10.48550/arXiv.1904.05342&lt;/a>.&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>PPV: 阳性预测里面真正的阳性比例&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>recall: 正样本中实际预测为正，即真阳性率&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>token: 将原始文本切分成子单元的过程就叫做Tokenization，子单元即token&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Embedding是什么？</title><link>https://youngforever.tech/posts/20230222-embedding/</link><pubDate>Tue, 21 Feb 2023 23:13:00 +0000</pubDate><guid>https://youngforever.tech/posts/20230222-embedding/</guid><description>
&lt;script>
document.addEventListener("DOMContentLoaded", function() {
renderMathInElement(document.body, {
delimiters: [
{left: '$$', right: '$$', display: true},
{left: '$', right: '$', display: false},
{left: '\\(', right: '\\)', display: false},
{left: '\\[', right: '\\]', display: true}
],
throwOnError : false
});
});
&lt;/script>
&lt;p>
&lt;figure>&lt;img src="https://cdn.jsdelivr.net/gh/jmwyf/pichosting@master/embedding.png" alt="" class="mx-auto my-0 rounded-md" />
&lt;/figure>
&lt;/p>
&lt;h2 id="背景" class="relative group">背景 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%83%8c%e6%99%af" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>在nlp领域，如何把词进行编码成数字，从而能输入到数学模型是需要考虑的：&lt;/p>
&lt;p>索引编码&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>：&lt;/p>
&lt;ul>
&lt;li>整数编码，特征之间的关系无法捕捉&lt;/li>
&lt;/ul>
&lt;p>one-hot编码的缺点：&lt;/p>
&lt;ul>
&lt;li>对于具有非常多类型的类别变量，变换后的向量维数过于巨大，且过于稀疏。&lt;/li>
&lt;li>映射之间完全独立，并不能表示出不同类别之间的关系。&lt;/li>
&lt;/ul>
&lt;h2 id="embedding是什么" class="relative group">Embedding是什么 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#embedding%e6%98%af%e4%bb%80%e4%b9%88" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>嵌入是将正整数（索引值）转换为固定尺寸的稠密向量&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>。这句话来着keras文档中对embedding层的解释，非常概括，不太容易理解，但确实概括了要干的事情。&lt;/p>
&lt;p>比如一句话，“我爱中国”对应的索引为[0,1,2,3]，要将这个索引转化为固定大小且稠密的向量来表示，而不是稀疏的one-hot编码。可以表示为$[[0.2, 0.5], [0.6,-0.1], [0.8, 0.4], [0.5, 0.5]]$，。&lt;/p>
&lt;p>词嵌入通常是8-1024维度，根据数据量的大小来调整，高维度的嵌入能更好的捕捉词之间的关系，但是需要更多的数据来训练。&lt;/p>
&lt;h2 id="embedding是如何实现的" class="relative group">Embedding是如何实现的 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#embedding%e6%98%af%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e7%9a%84" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>通过Embedding层实现，embedding层可以看作是一张从索引映射到稠密向量的查找表，当使用embedding层的时候，embedding层和神经网络其他层一样，权重是随机初始化的。根据你的训练任务，embedding层通过反向传播逐渐调整。&lt;/p>
&lt;p>embedding层的具体结构即[索引长度，emb维度]的权重矩阵也可以看作查询表，输入为整数索引，对应权重矩阵即词嵌入。skip-gram模型的前半部分即词嵌入。&lt;/p>
&lt;p>例如在tensorflow中，用于句子分类时的嵌入层，输入是整数索引，经过嵌入层、池化层、全连接输入训练可以得到嵌入层权重，即词嵌入。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">embedding_dim&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">16&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">model&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Sequential&lt;/span>&lt;span class="p">([&lt;/span> 
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">vectorize_layer&lt;/span>&lt;span class="p">,&lt;/span> 
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Embedding&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">vocab_size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">embedding_dim&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s2">&amp;#34;embedding&amp;#34;&lt;/span>&lt;span class="p">),&lt;/span> 
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">GlobalAveragePooling1D&lt;/span>&lt;span class="p">(),&lt;/span>  &lt;span class="n">Dense&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">16&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">activation&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;relu&amp;#39;&lt;/span>&lt;span class="p">),&lt;/span> 
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">Dense&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="应用" class="relative group">应用 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%ba%94%e7%94%a8" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>最常用的就是词嵌入表达，但是万物可嵌入。Embedding在输入数据没有较好的数据表示时，能将输入数据根据下游任务转化为可学习的高维度向量表示，比如输入的为单词、图片或者输入的为空间位置等。&lt;/p>
&lt;p>mnist数据集中的图片，可以通过嵌入层来表示，如下图所示，每个点代表一个图片(10000*784)，通过嵌入层，将图片的像素点转化为稠密的向量，然后通过t-SNE/pca降维，可以看到图片的空间分布。(generated by copilot)
&lt;figure>&lt;img src="https://cdn.jsdelivr.net/gh/jmwyf/pichosting@master/mnistembedding.png" alt="" class="mx-auto my-0 rounded-md" />
&lt;/figure>
&lt;/p>
&lt;p>在进行特征工程时，很难捕捉空间(时间)维度。通过使用深度学习嵌入层，我们可以通过提供一系列用户行为(作为索引)作为模型的输入来有效地捕捉这个空间维度。&lt;/p>
&lt;p>我的博客即将同步至腾讯云开发者社区，邀请大家一同入驻：https://cloud.tencent.com/developer/support-plan?invite_code=2cy4t3peazy8s&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>&lt;a href="https://www.tensorflow.org/text/guide/word_embeddings" target="_blank" rel="noreferrer">Word embeddings  |  Text  |  TensorFlow&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>&lt;a href="https://keras.io/zh/layers/embeddings/" target="_blank" rel="noreferrer">嵌入层 Embedding - Keras 中文文档&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>Skip-gram模型（1）</title><link>https://youngforever.tech/posts/20230205-skip-gram-part1/</link><pubDate>Sun, 05 Feb 2023 10:58:02 +0000</pubDate><guid>https://youngforever.tech/posts/20230205-skip-gram-part1/</guid><description>
&lt;script>
document.addEventListener("DOMContentLoaded", function() {
renderMathInElement(document.body, {
delimiters: [
{left: '$$', right: '$$', display: true},
{left: '$', right: '$', display: false},
{left: '\\(', right: '\\)', display: false},
{left: '\\[', right: '\\]', display: true}
],
throwOnError : false
});
});
&lt;/script>
&lt;h2 id="简介" class="relative group">简介 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e7%ae%80%e4%bb%8b" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>Skip-gram&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>属于Word2Vec的一种，给定input，预测上下文，而CBOW（见补充）是通过上下文来预测input。&lt;/p>
&lt;p>Word2Vec模型分为两个步骤&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>：&lt;/p>
&lt;ul>
&lt;li>建立模型，这类方法与自编码模型有点像，建模不是最终目的；&lt;/li>
&lt;li>通过模型获取嵌入词向量。&lt;/li>
&lt;/ul>
&lt;h2 id="模型细节" class="relative group">模型细节 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%a8%a1%e5%9e%8b%e7%bb%86%e8%8a%82" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>整体框架图&lt;/p>
&lt;h3 id="输入层" class="relative group">输入层 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%be%93%e5%85%a5%e5%b1%82" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>词不能直接输入神经网络模型，比如训练样本中有10000个不同的词，将某个词“我”或者“我们”进行one-hot编码，形成10000维的向量，其中“我”的地方为1，其他均为0。对于Skip-gram输入单个词向量，输出就是这个词附近的词组成的向量。&lt;/p>
&lt;p>模型输入输出均为10000维度向量$\{0,1\}^{10000}$&lt;/p>
&lt;h3 id="隐含层" class="relative group">隐含层 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e9%9a%90%e5%90%ab%e5%b1%82" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>假如想用300个特征来表征词，那么隐含层单个神经元权重为[10000, 1]，300个神经元为[10000, 300]
&lt;figure>&lt;img src="https://cdn.jsdelivr.net/gh/jmwyf/pichosting@master/sghidden.png" alt="" class="mx-auto my-0 rounded-md" />
&lt;/figure>
&lt;/p>
&lt;p>上图可以理解为输入经过隐含层作用刚好得到单词的表征。输入和隐含层两部分可以进行词嵌入即embedding。&lt;/p>
&lt;h3 id="输出层" class="relative group">输出层 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%be%93%e5%87%ba%e5%b1%82" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>模型输出为10000维度向量，要达到这样的输出层为10000个神经元，并且这些神经元输出和为1，使用softmax函数来达到这种效果。以下两个等式展示一个词向量在神经网络中的前向传播。&lt;/p>
&lt;p>$$
\begin{bmatrix}
1 &amp;amp; 10000
\end{bmatrix}
\times
\begin{bmatrix}
10000 &amp;amp; 300
\end{bmatrix}
=
\begin{bmatrix}
1 &amp;amp; 300
\end{bmatrix} \
$$&lt;/p>
&lt;p>$$
\begin{bmatrix}
1 &amp;amp; 300
\end{bmatrix}
\times
\begin{bmatrix}
300 &amp;amp; 10000
\end{bmatrix}
=
\begin{bmatrix}
1 &amp;amp; 10000
\end{bmatrix} \
$$&lt;/p>
&lt;h2 id="补充" class="relative group">补充 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%a1%a5%e5%85%85" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>skip-gram名字由来&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>：&lt;/p>
&lt;p>首先n-gram是一系列连续的词（tokens），而skip-gram，或者skip-n-gram，skip的是token之间的gap，jumps over the是一个3-gram，那么(jumps, the)刚好skip了一个gram (over)。&lt;/p>
&lt;p>什么是Softmax？&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>&lt;/p>
&lt;p>Softmax从字面上来说，可以分成soft和max两个部分。max故名思议就是最大值的意思。Softmax的核心在于soft，而soft有软的含义，与之相对的是hard硬。很多场景中需要我们找出数组所有元素中值最大的元素，实质上都是求的hardmax。hardmax最大的特点就是只选出其中一个最大的值，即非黑即白。Softmax的含义就在于不再唯一的确定某一个最大值，而是为每个输出分类的结果都赋予一个概率值，表示属于每个类别的可能性。经过使用指数形式的Softmax函数能够将差距大的数值距离拉的更大。&lt;/p>
&lt;p>CBOW是什么？&lt;/p>
&lt;p>Continuous Bag of Word Model连续词带模型，通过上下文来预测中间的词&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>&lt;a href="http://mccormickml.com/2016/04/19/word2vec-tutorial-the-skip-gram-model/" target="_blank" rel="noreferrer">Word2Vec Tutorial - The Skip-Gram Model · Chris McCormick&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/27234078?from=singlemessage" target="_blank" rel="noreferrer">理解 Word2Vec 之 Skip-Gram 模型 - 知乎&lt;/a>&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>&lt;a href="https://www.zhihu.com/question/302594410?utm_id=0" target="_blank" rel="noreferrer">skip-gramm模型skip了什么？为什么叫skip-gramm模型？ - 知乎&lt;/a>&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/105722023" target="_blank" rel="noreferrer">一文详解Softmax函数 - 知乎&lt;/a>&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>公开重症监护数据库MIMIC代码仓库介绍</title><link>https://youngforever.tech/posts/20230204-mimic-code/</link><pubDate>Sat, 04 Feb 2023 10:57:02 +0000</pubDate><guid>https://youngforever.tech/posts/20230204-mimic-code/</guid><description>&lt;div class="lead !mb-9 text-xl">
《The MIMIC Code Repository: Enabling reproducibility in critical care research》论文
&lt;/div>
&lt;h2 id="引言" class="relative group">引言 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%bc%95%e8%a8%80" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ul>
&lt;li>科学结果的可重复性越来越受到关注&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>；&lt;/li>
&lt;li>医疗领域进入数字化革命（本文是2017年接收），引出形成MIMIC-III数据库；&lt;/li>
&lt;li>EHR二次分析需要临床专家和数据科学家的合作，在EHR数据库上推导或者定义一些概念是需要资源的，对于没有特别强的临床背景或者数据科学技能的人来说巨大障碍；&lt;/li>
&lt;li>该文介绍MIMIC代码仓库，介绍与重症相关概念的导出以及相关假设条件等；&lt;/li>
&lt;li>公开数据已经逐渐有了，公开相应的数据代码同样重要。加速并提升未来研究的一致性以及有效性。&lt;/li>
&lt;/ul>
&lt;h2 id="代码仓库详情" class="relative group">代码仓库详情 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e4%bb%a3%e7%a0%81%e4%bb%93%e5%ba%93%e8%af%a6%e6%83%85" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ul>
&lt;li>Concepts
&lt;ul>
&lt;li>从电子病历中提取重要概念的代码。比如提取AKI的模块&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Executable documents
&lt;ul>
&lt;li>可执行的Notebooks文件，可重复的示例研究或者教程&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Community
&lt;ul>
&lt;li>建立公开讨论便于社区成员贡献&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="概念concepts" class="relative group">概念concepts &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%a6%82%e5%bf%b5concepts" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>代码库中常用的概念&lt;/p>
&lt;h4 id="疾病严重程度评分severity-of-illness-scores" class="relative group">疾病严重程度评分Severity of illness scores &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e7%96%be%e7%97%85%e4%b8%a5%e9%87%8d%e7%a8%8b%e5%ba%a6%e8%af%84%e5%88%86severity-of-illness-scores" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h4>&lt;p>在回顾性数据库中难以计算&lt;/p>
&lt;ul>
&lt;li>大多都是在前瞻性实验中获取的；&lt;/li>
&lt;li>常规收集的数据缺相应元素。有些特征未纳入结构化电子病历系统，另外则是对某种情况的患者没有统一的协议来定义状态&lt;/li>
&lt;/ul>
&lt;p>目前MIMIC代码库中有：&lt;/p>
&lt;ul>
&lt;li>acute physiology score(APS)-III&lt;/li>
&lt;li>simplified acute physiology score(SAPS)&lt;/li>
&lt;li>SAPS-II&lt;/li>
&lt;li>Oxford acute severity of illness score(OASIS)&lt;/li>
&lt;/ul>
&lt;h4 id="器官衰竭organ-dysfunction-scores" class="relative group">器官衰竭Organ dysfunction scores &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%99%a8%e5%ae%98%e8%a1%b0%e7%ab%adorgan-dysfunction-scores" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h4>&lt;p>SOFA计算方式不同，由于GCS评分定义不同&lt;/p>
&lt;p>Sequential Organ Failure Assessment(SOFA), Logistic Organ Dysfunction system(LODS)&lt;/p>
&lt;h4 id="治疗时间time-of-treatment" class="relative group">治疗时间Time of treatment &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%b2%bb%e7%96%97%e6%97%b6%e9%97%b4time-of-treatment" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h4>&lt;p>由于数据获取的限制，许多药物和确切的治疗时间无法得出，需要根据临床经验识别其他可替代的数据&lt;/p>
&lt;ul>
&lt;li>机械通气时长：识别机械通气时长需要复杂的逻辑规则（文中图3）&lt;/li>
&lt;li>血管加压药物使用&lt;/li>
&lt;li>CRRT&lt;/li>
&lt;/ul>
&lt;h4 id="脓毒症sepsis" class="relative group">脓毒症sepsis &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%84%93%e6%af%92%e7%97%87sepsis" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h4>&lt;p>sepsis定义有多种版本，这里给出了&lt;em>Angus 2001，Martin 2003，Iwashyna 2014&lt;/em>三个版本&lt;/p>
&lt;h4 id="共病comorbidities" class="relative group">共病Comorbidities &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%85%b1%e7%97%85comorbidities" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h4>&lt;p>给出了4个版本&lt;/p>
&lt;ul>
&lt;li>&lt;em>Elixhauser A 1998&lt;/em>&lt;/li>
&lt;li>American Health and Research Quality group（AHRQ）&lt;/li>
&lt;li>&lt;em>Quan 2005&lt;/em>&lt;/li>
&lt;li>&lt;em>Van Walraven 2009&lt;/em>&lt;/li>
&lt;/ul>
&lt;h4 id="concept指南" class="relative group">concept指南 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#concept%e6%8c%87%e5%8d%97" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h4>&lt;p>
&lt;figure>&lt;img src="https://cdn.jsdelivr.net/gh/jmwyf/pichosting@master/mimicroadmap.png" alt="" class="mx-auto my-0 rounded-md" />
&lt;/figure>
&lt;/p>
&lt;h3 id="可执行文档" class="relative group">可执行文档 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%8f%af%e6%89%a7%e8%a1%8c%e6%96%87%e6%a1%a3" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>当数据和代码都公开可获取，提供一种研究可以被重现的框架，基于Rmd或notebook给出实例。&lt;/p>
&lt;ul>
&lt;li>&lt;em>Hsu 2015&lt;/em>研究复现
&lt;ul>
&lt;li>indwelling arterial catheters and their association with in-hospital mortality for hemodynamically stable patients with respiratory failure&lt;/li>
&lt;li>&lt;code>aline.ipynb&lt;/code>提取数据&lt;/li>
&lt;li>&lt;code>aline.Rmd&lt;/code>数据分析&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>教程
&lt;ul>
&lt;li>definition of CRRT&lt;/li>
&lt;li>introduction to SQL&lt;/li>
&lt;li>a step-by-step guide to selecting a study cohort&lt;/li>
&lt;li>an outline of the data-capture process&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="社区" class="relative group">社区 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e7%a4%be%e5%8c%ba" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>让研究人员和数据维护人员、临床人员共同提升代码&lt;/p>
&lt;h2 id="结论" class="relative group">结论 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e7%bb%93%e8%ae%ba" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>公开数据库的案例已经不少，为了让研究更加透明，也需要公开相应数据分析和数据处理的代码&lt;/p>
&lt;h2 id="补充" class="relative group">补充 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%a1%a5%e5%85%85" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ul>
&lt;li>代码库地址：https://github.com/MIT-LCP/mimic-code
&lt;ul>
&lt;li>之前以MIMIC-III为主，现在mimic-iii和mimic-iv合并在一起了&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>mimic数据库为了让研究者访问更加方便，很大一个改变是部署在云上比如google的云平台，云平台上需要big query语法来访问，所以现在代码库关于数据提取的代码更新以big query为主，需要通过脚本转化为适合postgres语法
&lt;ul>
&lt;li>Open a terminal in the &lt;code>concepts&lt;/code> folder.&lt;/li>
&lt;li>Run &lt;a href="https://github.com/MIT-LCP/mimic-code/blob/main/mimic-iv/concepts/convert_bigquery_to_postgres.sh" target="_blank" rel="noreferrer">convert_bigquery_to_postgres.sh&lt;/a>.
&lt;ul>
&lt;li>e.g. &lt;code>bash convert_bigquery_to_postgres.sh&lt;/code>&lt;/li>
&lt;li>This file outputs the scripts to the &lt;a href="https://github.com/MIT-LCP/mimic-code/blob/main/mimic-iv/concepts/postgres" target="_blank" rel="noreferrer">postgres&lt;/a> subfolder after applying a few changes.&lt;/li>
&lt;li>This also creates the &lt;code>postgres_make_concepts.sql&lt;/code> script in the postgres subfolder.&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>从代码仓库导出的概念concepts都放到&lt;code>mimic_derived&lt;/code>数据集里&lt;/li>
&lt;/ul>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>Johnson, A. E. W., Stone, D. J., Celi, L. A. &amp;amp; Pollard, T. J. The MIMIC Code Repository: enabling reproducibility in critical care research. &lt;em>J Am Med Inform Assn&lt;/em> &lt;strong>25&lt;/strong>, 32–39 (2018).&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>公开重症监护数据库MIMIC-IV介绍</title><link>https://youngforever.tech/posts/20230117-mimiciv/</link><pubDate>Tue, 17 Jan 2023 00:00:00 +0000</pubDate><guid>https://youngforever.tech/posts/20230117-mimiciv/</guid><description>&lt;h2 id="背景" class="relative group">背景 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%83%8c%e6%99%af" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ul>
&lt;li>本文&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>首先介绍mimic项目的由来，医院数据归档系统都不是为研究设计的，难以访问以及查询；&lt;/li>
&lt;li>MIMIC从0-4发展简介；&lt;/li>
&lt;li>其他数据库简介
&lt;ul>
&lt;li>eICU-CRD，美国多中心200859例ICU记录&lt;/li>
&lt;li>AmsterdamUMCdb，荷兰单医学中心20109例患者23106次入院记录&lt;/li>
&lt;li>HiRID&lt;a href="https://hirid.intensivecare.ai/data-details" target="_blank" rel="noreferrer">Data details&lt;/a>，瑞士34000入院患者高分辨率数据（每两分钟一个数据点，712中常规手机生理数据）
&lt;ul>
&lt;li>HiRID has a higher time resolution than other published datasets, most importantly for bedside monitoring with most parameters recorded every 2 minutes&lt;/li>
&lt;li>去隐私化方法可以借鉴&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>PIC，中国12881例患者13941次儿科ICU记录&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>问题，当前数据库都只是单模态的数据或各有特点，且临床实践发展变化快，数据库需要不断更新完善；&lt;/li>
&lt;li>MIMIC-IV是当代的综合多模态数据库&lt;/li>
&lt;/ul>
&lt;h2 id="方法" class="relative group">方法 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%96%b9%e6%b3%95" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>mimic-iv数据库是怎么建的？&lt;/p>
&lt;ul>
&lt;li>获取、转化、去隐私化&lt;/li>
&lt;/ul>
&lt;h3 id="获取" class="relative group">获取 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%8e%b7%e5%8f%96" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>BIDMC医院常规的临床数据存储在microsoft SQL中，通过VPN转移到MIT服务器的PostgreSQL，补充数据如ICD、患者死亡信息等外部导入到PostgreSQL&lt;/p>
&lt;ul>
&lt;li>队列：2008-2019，18岁以上&lt;/li>
&lt;li>床旁信息来自于MetaVision，医院EHR会通过HL7推信息到MetaVision&lt;/li>
&lt;li>外部数据主要说明DRGs和ICD是如何处理以及死亡信息如何处理
&lt;ul>
&lt;li>DRGs和ICD由于数据库跨度时间长以及不同版本，在数据库中把这些都导入了&lt;/li>
&lt;li>死亡信息通过与马萨诸塞州生命记录和统计登记处进行匹配，而非社保档案&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="转化" class="relative group">转化 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%bd%ac%e5%8c%96" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>转化有两条原则&lt;/p>
&lt;ul>
&lt;li>与MIMIC-III保持兼容&lt;/li>
&lt;li>尽量减少处理过程让公开数据与临床实践数据保持一致&lt;/li>
&lt;/ul>
&lt;p>数据被分为三个组：hosp、icu和note&lt;/p>
&lt;ul>
&lt;li>hosp：admission/discharge/transfer（ADT），实验室检查结果，微生物培养，处方，管理数据&lt;/li>
&lt;li>icu：患者出入量、输液、操作、记录到的观测值等&lt;/li>
&lt;li>note：出院总结和放射学报告，也创建了相对应的自由文本结构化表“实体-属性-值”&lt;/li>
&lt;/ul>
&lt;h3 id="去隐私化" class="relative group">去隐私化 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e5%8e%bb%e9%9a%90%e7%a7%81%e5%8c%96" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>遵从The Health Insurance Portability and Accountability Act（HIPAA）条款规定了18项标识符，包括姓名、地址、年龄等需要去掉&lt;/li>
&lt;li>日期移动，但时间点间距保留&lt;/li>
&lt;li>结合了两个公开的算法&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>从自由文本中移除个人健康信息（PHI）
&lt;ul>
&lt;li>两个算法都没捕捉到的，从数据库中移除？这个没写具体怎么做&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="数据记录结果" class="relative group">数据记录结果 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%95%b0%e6%8d%ae%e8%ae%b0%e5%bd%95%e7%bb%93%e6%9e%9c" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>这一部分类似传统论文的结果，详细介绍了hosp、icu、note模块里面的数据情况，对各表进行介绍&lt;/p>
&lt;h3 id="hosp" class="relative group">Hosp &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#hosp" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>首先介绍模块里主要键值以及表之间连接关系，与MIMIC-III一致&lt;/p>
&lt;p>患者基本信息：patients、admissions和transfers表&lt;/p>
&lt;ul>
&lt;li>患者时间信息，anchor_year、anchor_age、anchor_year_group这几个重要项
&lt;ul>
&lt;li>anchor_year锚定年份，由于时间都是去隐私化的平移过的，这里可以看作平移之后的参考年份&lt;/li>
&lt;li>anchor_year_group是真实年份的区间&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>患者死亡信息最多到患者出院1年为止&lt;/li>
&lt;/ul>
&lt;p>管理信息：services、poe、poe_detail表&lt;/p>
&lt;ul>
&lt;li>services 患者住院期间所受到的医疗服务
&lt;ul>
&lt;li>
&lt;figure>&lt;img src="https://cdn.jsdelivr.net/gh/jmwyf/pichosting@master/services.png" alt="" class="mx-auto my-0 rounded-md" />
&lt;/figure>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>poe 医嘱录入系统：治疗和操作&lt;/li>
&lt;/ul>
&lt;p>计费信息：diagnoses_icd、procedures_icd、drgcodes、hcpcsevents&lt;/p>
&lt;p>检查结果：microbiologyevents、labevents&lt;/p>
&lt;p>药物信息：prescriptions、pharmacy、emar、emar_detail&lt;/p>
&lt;ul>
&lt;li>处方、药房信息；&lt;/li>
&lt;li>2016年部署electronic Medicine Administration Record，eMAR；&lt;/li>
&lt;li>看起来关系比较复杂使用得结合实例&lt;/li>
&lt;/ul>
&lt;h3 id="icu" class="relative group">ICU &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#icu" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>chartevents, d_items, datetimeevents, icustays, inputevents, outputevents, and procedureevents表&lt;/p>
&lt;h3 id="note" class="relative group">Note &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#note" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>出院总结：&lt;/p>
&lt;ul>
&lt;li>主诉、现病史、既往病史、简要病程、体格检查和出院诊断&lt;/li>
&lt;/ul>
&lt;p>放射学报告：&lt;/p>
&lt;ul>
&lt;li>x射线、CT、MRI、超声&lt;/li>
&lt;/ul>
&lt;h2 id="技术验证结果" class="relative group">技术验证结果 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%8a%80%e6%9c%af%e9%aa%8c%e8%af%81%e7%bb%93%e6%9e%9c" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ul>
&lt;li>完整性检查
&lt;ul>
&lt;li>数据库自身是完备的，不会出现某个患者的信息只出现一张表其他表都找不到的情况&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>一致性检查
&lt;ul>
&lt;li>数据结果与一些常识一致&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>去隐私化检查&lt;/li>
&lt;/ul>
&lt;h2 id="使用笔记" class="relative group">使用笔记 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e4%bd%bf%e7%94%a8%e7%ac%94%e8%ae%b0" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ul>
&lt;li>如何获取
&lt;ul>
&lt;li>参加课程&lt;/li>
&lt;li>签署data use agreement, DUA&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>代码库以及模版&lt;/li>
&lt;/ul>
&lt;h2 id="思考" class="relative group">思考 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%80%9d%e8%80%83" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ul>
&lt;li>MIMIC数据库一步一步发展已经来到了第四版，很好的体现了科学研究的可持续发展。&lt;/li>
&lt;li>与MIMIC-III论文写法不同，mimic-iv对数据库构建过程写的更加详细，可操作性更高，而mimic-iii由于没有很好的把这个过程结构化抽象分成几步显得构建细节不足，而mimic-iii论文表格比较丰富，对数据库进行了一些粗粒度的介绍，mimic-iv论文没有。个人认为iv这篇论文写的更好一点。&lt;/li>
&lt;li>伴随着数据类型越来越多、数据库越来越多，数据分析人员也需要掌握更多类型数据预处理方法。面对文本、图像、波形的多模态数据分析或者在不完备数据情况下模型的不确定性成为两个相对应的研究方向。&lt;/li>
&lt;/ul>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>Johnson, A. E. W. &lt;em>et al.&lt;/em> MIMIC-IV, a freely accessible electronic health record dataset. &lt;em>Sci Data&lt;/em> &lt;strong>10&lt;/strong>, 1 (2023).&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>Neamatullah, I. et al. Automated de-identification of free-text medical records. BMC medical informatics and decision making 8,1–17 (2008).&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>Johnson, A. E. W., Bulgarelli, L. &amp;amp; Pollard, T. J. Deidentification of free-text medical records using pre-trained bidirectional transformers. In Proceedings of the ACM Conference on Health, Inference, and Learning, 214–221 (2020).&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>MIT 6.S91 Introduction Deep Learning Notes</title><link>https://youngforever.tech/posts/20230113-introduction-deep-learning/</link><pubDate>Fri, 13 Jan 2023 16:59:00 +0000</pubDate><guid>https://youngforever.tech/posts/20230113-introduction-deep-learning/</guid><description>
&lt;script>
document.addEventListener("DOMContentLoaded", function() {
renderMathInElement(document.body, {
delimiters: [
{left: '$$', right: '$$', display: true},
{left: '$', right: '$', display: false},
{left: '\\(', right: '\\)', display: false},
{left: '\\[', right: '\\]', display: true}
],
throwOnError : false
});
});
&lt;/script>
&lt;h2 id="1introduction-to-deep-learning" class="relative group">1.Introduction to Deep learning &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#1introduction-to-deep-learning" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ul>
&lt;li>震撼，第一节课直接放大招，用自己拍摄的视频和奥巴马合成来介绍这门课程。&lt;/li>
&lt;li>&lt;strong>不管老师在课程上讲什么，希望你们能真正的思考为什么这一步是重要而且必须的，正是这些思考才能做出真正令人惊讶的突破。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h2 id="2deep-sequence-model" class="relative group">2.Deep Sequence Model &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#2deep-sequence-model" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>Three way to solve gradient vanish&lt;/p>
&lt;ul>
&lt;li>Gated Cells
&lt;ul>
&lt;li>LSTM
&lt;ul>
&lt;li>Forget&lt;/li>
&lt;li>Store&lt;/li>
&lt;li>Update&lt;/li>
&lt;li>Output&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Attention [[Transformer]]&lt;/li>
&lt;/ul>
&lt;h2 id="3deep-computer-vision" class="relative group">3.Deep Computer Vision &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#3deep-computer-vision" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ul>
&lt;li>介绍卷积操作，是一种提取特征的方法生成feature maps（还有其他的方法可以用吗？然后效果还不错）；
&lt;ul>
&lt;li>与全连接相比的优点；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Fast RCNN用于目标检测，怎么实现推荐特定区域图像？&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>医学图片分割&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>总结：
&lt;ul>
&lt;li>原理&lt;/li>
&lt;li>CNN架构&lt;/li>
&lt;li>应用&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="4deep-generative-models" class="relative group">4.Deep Generative Models &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#4deep-generative-models" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ul>
&lt;li>what 目标: 来自于一些分布中的训练样本，通过这些样本学习模型来表征这个分布；&lt;/li>
&lt;li>how 密度估计；神经网络适合来进行高维度表征；&lt;/li>
&lt;li>why
&lt;ul>
&lt;li>&lt;strong>Debiasing&lt;/strong>: Capable of uncovering underlying features in a dataset&lt;/li>
&lt;li>Outlier detection: how can we detect when we encounter something new or rare?&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>Latent variable representation:
&lt;ul>
&lt;li>举例事物的投影，只能看见影子即表象，而被灯光照射的实物是看不见的即隐变量；要做的是通过观察到的投影来对实物进行建模&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Autoencoder: reconstruction loss
&lt;ul>
&lt;li>完全是确定性性&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;ul>
&lt;li>VAEs：normal prior + regularization
&lt;ul>
&lt;li>reconstruction loss + regularization term&lt;/li>
&lt;li>encoder: $q_\phi(z|x)$&lt;/li>
&lt;li>decoder: $p_\theta(x|z)$&lt;/li>
&lt;li>KL-divergence: $D(q_\phi(z|x)||p(z))$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>
&lt;figure>&lt;img src="https://cdn.jsdelivr.net/gh/jmwyf/pichosting@master/VAEsummary.png" alt="" class="mx-auto my-0 rounded-md" />
&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>GANs
&lt;ul>
&lt;li>make a generative model by having two neural networks compete with each other&lt;/li>
&lt;li>⭐️CycleGAN: domain transformations 视频开头的视频就是用这个合成&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="5deep-reinforcement-learning" class="relative group">5.Deep reinforcement learning &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#5deep-reinforcement-learning" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ul>
&lt;li>Reward: $$R_t = r_t + \gamma r_{t+1} + \gamma^2 r_{t+2} + &amp;hellip;$$&lt;/li>
&lt;li>Q-function: expected total future reward $$Q(s_t, a_t) = E[R_t|s_t, a_t]$$&lt;/li>
&lt;li>Policy: to infer the best action to take at its state, choose an action that maximizes future reward $$\pi^*(s)=\mathop{\arg\max}\limits_{s}Q(s, a)$$&lt;/li>
&lt;li>Value Learning
&lt;ul>
&lt;li>find $Q(s, a)$&lt;/li>
&lt;li>$a = \mathop{\arg\max}\limits_{a}Q(s, a)$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Police Learning
&lt;ul>
&lt;li>find $\pi(s)$&lt;/li>
&lt;li>sample $a\sim\pi(s)$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Deep Q Network(DQN)&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Policy Gradient&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> AlphaGo&lt;/li>
&lt;/ul>
&lt;h2 id="6dl-limitations-and-new-frontiers" class="relative group">6.DL Limitations and New Frontiers &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#6dl-limitations-and-new-frontiers" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ul>
&lt;li>limitations
&lt;ul>
&lt;li>Generalization
&lt;ul>
&lt;li>data is important&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Uncertainty in Deep learning&lt;/li>
&lt;li>adversarial attack&lt;/li>
&lt;li>Algorithmic Bias&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Frontiers
&lt;ul>
&lt;li>encoder
&lt;ul>
&lt;li>many real world data cannot be captured by standard encodings&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> GCN（Graph Convolutional Networks）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Automated AI&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="7-lidar-for-autonomous-driving" class="relative group">7. LiDAR for Autonomous Driving &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#7-lidar-for-autonomous-driving" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>@INNOVIZ&lt;/p>
&lt;ul>
&lt;li>Camera Vs LiDAR
&lt;ul>
&lt;li>互补，视线不好的情况&lt;/li>
&lt;li>冗余能保证准确&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Safety and Comfort&lt;/li>
&lt;/ul>
&lt;h2 id="8-automatic-speech-recognition" class="relative group">8. Automatic Speech Recognition &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#8-automatic-speech-recognition" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>@Rev&lt;/p>
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> Conformer&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> CTC&lt;/li>
&lt;/ul>
&lt;h2 id="9-ai-fore-science" class="relative group">9. AI fore Science &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#9-ai-fore-science" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>Principled AI Algorithms for challenging domains
@Caltech&lt;/p>
&lt;h2 id="10-uncertainty-in-deep-learning" class="relative group">10. Uncertainty in Deep Learning &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#10-uncertainty-in-deep-learning" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>longer version：NeurIPS 2020 Tutorial
@Google AI Brain Team&lt;/p>
&lt;ul>
&lt;li>Return a distribution over predictions rather than a single prediction&lt;/li>
&lt;li>Out-of-Distribution Robustness
&lt;ul>
&lt;li>covariate shift: distribution of features changes&lt;/li>
&lt;li>open-set recognition: new classes may appear at test time&lt;/li>
&lt;li>label shift: distribution of label changes&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>sources of uncertainty
&lt;ul>
&lt;li>Model uncertainty
&lt;ul>
&lt;li>认知上的不确定性&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>Data uncertainty
&lt;ul>
&lt;li>human disagreement label noise&lt;/li>
&lt;li>measurement noise&lt;/li>
&lt;li>missing data&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>how to compute
&lt;ul>
&lt;li>&lt;input disabled="" type="checkbox"> BDN&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> GP&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> Deep Ensemble&lt;/li>
&lt;li>&lt;input disabled="" type="checkbox"> MCMC&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>multi-input and multi output（MIMO）&lt;/li>
&lt;li>how to communicate with uncertainty?&lt;/li>
&lt;/ul>
&lt;p>7-10讲很一般，一个复杂的主题，需要将背景讲清楚，公司讲东西也没啥具体细节。&lt;/p>
&lt;h2 id="ref" class="relative group">Ref &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#ref" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ol>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1jo4y1d7R6/?spm_id_from=333.1007.top_right_bar_window_custom_collection.content.click&amp;amp;vd_source=c2e29329f33c2e7eb04916d212234ad6" target="_blank" rel="noreferrer">【双语字幕】MIT《深度学习导论(6.S191)》课程(2021)_哔哩哔哩_bilibili&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://introtodeeplearning.com/" target="_blank" rel="noreferrer">introtodeeplearning.com&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=QcLlc9lj2hk&amp;amp;list=PLtBw6njQRU-rwp5__7C0oIVt26ZgjG9NI&amp;amp;index=4" target="_blank" rel="noreferrer">MIT 6.S191: Deep Generative Modeling - YouTube&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>《A Unified Approach to interpreting Model Predictions》论文解读</title><link>https://youngforever.tech/posts/20230106-shap/</link><pubDate>Fri, 06 Jan 2023 16:59:00 +0000</pubDate><guid>https://youngforever.tech/posts/20230106-shap/</guid><description>
&lt;script>
document.addEventListener("DOMContentLoaded", function() {
renderMathInElement(document.body, {
delimiters: [
{left: '$$', right: '$$', display: true},
{left: '$', right: '$', display: false},
{left: '\\(', right: '\\)', display: false},
{left: '\\[', right: '\\]', display: true}
],
throwOnError : false
});
});
&lt;/script>
&lt;h2 id="introduction" class="relative group">Introduction &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#introduction" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ul>
&lt;li>大数据让复杂模型的优势明显&lt;/li>
&lt;li>提出一种新颖统一的方法用于模型解释
&lt;ul>
&lt;li>用模型的方法来解释复杂模型（用魔法打败魔法）&lt;/li>
&lt;li>提出SHAP值作为各种方法近似统一特征重要度度量&lt;/li>
&lt;li>提出新的SHAP值估计方法&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h2 id="interpretation-model-properties" class="relative group">Interpretation model properties &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#interpretation-model-properties" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>描述解释模型需要有的三个性质，而现在解释方法的缺陷有哪些&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/p>
&lt;ul>
&lt;li>局部准确性：如果x‘是x的简化特征，对应解释模型g(x&amp;rsquo;) = f(x)，即解释模型在给定的特征情况下能解释为什么模型预测值是这么多。&lt;/li>
&lt;li>缺失性：当x&amp;rsquo;=0的时候，贡献度$\phi$为0&lt;/li>
&lt;li>一致性：模型改变导致特征变的更重要时，贡献度也应该变大&lt;/li>
&lt;/ul>
&lt;h2 id="additive-feature-attribution-methods" class="relative group">Additive Feature Attribution methods &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#additive-feature-attribution-methods" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>一大类方法中解释模型是一系列二元变量的线性函数
称为&lt;strong>Additive Feature Attribution methods&lt;/strong>（AFA）相加特征归因方法
$$g(z&amp;rsquo;) = \phi_0 + \sum_{i=1}^{M}\phi_i z&amp;rsquo;_{i}$$
$z&amp;rsquo; \in {0, 1}^M$&lt;/p>
&lt;h2 id="classic-shapley-value-estimation" class="relative group">Classic Shapley Value Estimation &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#classic-shapley-value-estimation" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>$$\phi_{i} = \sum_{S \subseteq F\backslash{i}}\frac{|S|!(|F|-|S|-1)!}{|F|!}[f_{S\cup{i}}(x_{S\cup{i}})-f_{S(x_S)}]$$
基于上面公式精确计算很麻烦，特征的排列有$2^F$种，计算量巨大&lt;/p>
&lt;h2 id="shap" class="relative group">SHAP &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#shap" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>SHAP分为模型无关和模型相关两类方法用来近似求解，模型无关的代表是kernelSHAP，而模型相关的代表则有DeepSHAP和TreeSHAP，一个是针对深度学习，一个是针对树模型。&lt;/p>
&lt;h2 id="kernel-shap" class="relative group">Kernel SHAP &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#kernel-shap" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;h3 id="lime" class="relative group">LIME &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#lime" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>LIME&lt;sup id="fnref:2">&lt;a href="#fn:2" class="footnote-ref" role="doc-noteref">2&lt;/a>&lt;/sup>（Local interpretable model-agnostic explanations)（why should I trust you: Explaining the predictions of any classifier）通过生成的包含需要解释点周围的扰动数据和基于黑箱模型预测结果的数据集，训练一个可以解释的模型，比如逻辑回归、决策树，这个可解释模型需要在解释点周围达到较好的效果。
$$\xi = \mathop{\arg\min}\limits_{g\in G}L(f,g,\pi_x) + \Omega(g)$$&lt;/p>
&lt;ul>
&lt;li>f为需解释模型&lt;/li>
&lt;li>g为可能的解释模型&lt;/li>
&lt;li>$\pi_x$为定义实例周围多大范围&lt;/li>
&lt;/ul>
&lt;p>算法过程：&lt;/p>
&lt;ul>
&lt;li>选择需要解释感兴趣的实例&lt;/li>
&lt;li>对其进行扰动，并得到黑箱模型对应结果产生新数据集&lt;/li>
&lt;li>根据与实例的接近程度，对新数据集进行赋予权重&lt;/li>
&lt;li>基于新数据集和上述损失函数求解可解释模型&lt;/li>
&lt;li>解释预测值
&lt;figure>&lt;img src="https://cdn.jsdelivr.net/gh/jmwyf/pichosting@master/weightshap.png" alt="" class="mx-auto my-0 rounded-md" />
&lt;/figure>
Figure 3: Toy example to present intuition for LIME&lt;/li>
&lt;/ul>
&lt;h3 id="kernelshaplinear-lime--shapley-value" class="relative group">KernelSHAP（Linear LIME + Shapley value） &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#kernelshaplinear-lime--shapley-value" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>LIME（Local interpretable model-agnostic explanations）方法的拓展，通过修改LIME需要求解loss等式参数，其主要思路是利用核变换，让$\phi$符合shapley value&lt;sup id="fnref:3">&lt;a href="#fn:3" class="footnote-ref" role="doc-noteref">3&lt;/a>&lt;/sup>
算法过程&lt;sup id="fnref:4">&lt;a href="#fn:4" class="footnote-ref" role="doc-noteref">4&lt;/a>&lt;/sup>：&lt;/p>
&lt;ul>
&lt;li>根据$z_k^{&amp;rsquo;} \in {0, 1}^M$选择k个样本&lt;/li>
&lt;li>将$z_k^{&amp;rsquo;} \in {0, 1}^M$转化为原始特征值并计算黑箱模型预测值&lt;/li>
&lt;li>基于SHAP kernel计算$z_k^{&amp;rsquo;}$ 样本权重，$z_k$里面1的个数不一样权重就不一样&lt;/li>
&lt;li>拟合线性模型&lt;/li>
&lt;li>从线性模型中返回Shapley values
SHAP核为(推导过程见2补充材料)：
$$\pi_{x&amp;rsquo;}(z&amp;rsquo;)= \frac{(M-1)}{(M choose |z&amp;rsquo;|)|z&amp;rsquo;|(M-|z&amp;rsquo;|)}$$
$$L(f,g, \pi_{x&amp;rsquo;})=\sum_{z&amp;rsquo;\in Z}[f(h_x^{-1}(z&amp;rsquo;))-g(z&amp;rsquo;)]^2\pi_{x&amp;rsquo;}(z&amp;rsquo;)$$
x&amp;rsquo;为简化输入，$x=h_x(x&amp;rsquo;)$, $z&amp;rsquo; \subseteq x&amp;rsquo;$
其中第二步：The function h maps 1’s to the corresponding value from the instance x that we want to explain. For tabular data, it maps 0’s to the values of another instance that we sample from the data. This means that we equate “feature value is absent” with “feature value is replaced by random feature value from data”.&lt;/li>
&lt;/ul>
&lt;h2 id="deep-shap" class="relative group">Deep SHAP &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#deep-shap" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;h3 id="deepliftlearning-important-features" class="relative group">DeepLIFT（Learning Important FeaTures） &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#deepliftlearning-important-features" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>DeepLIFT&lt;sup id="fnref:5">&lt;a href="#fn:5" class="footnote-ref" role="doc-noteref">5&lt;/a>&lt;/sup>方法使用神经元的激活与其“参考”进行比较，其中参考是神经元在网络获得“参考输入”时具有的激活状态（参考输入根据具体任务的内容定义）。该方法赋予每个特征重要度分数之和等于预测值与基于参考输入的预测值之间的差异&lt;sup id="fnref:6">&lt;a href="#fn:6" class="footnote-ref" role="doc-noteref">6&lt;/a>&lt;/sup>。
能解决基于梯度方法的不足，例如参考的差异不是0的情况下梯度仍然可能是0。
$$\sum_{i=1}^n C_{\Delta x_i \Delta t} = \Delta t \tag1$$
$\Delta t = t - t^0$, 神经元输出与参考输出的差异，$\Delta x$输入相对参考输入的变化， C即特征的贡献&lt;/p>
&lt;p>$$m_{\Delta x\Delta t} = \frac{C_{\Delta x\Delta t}}{\Delta x} \tag2$$
定义乘子multiplier，满足链式法则
算法步骤&lt;sup id="fnref:7">&lt;a href="#fn:7" class="footnote-ref" role="doc-noteref">7&lt;/a>&lt;/sup>：&lt;/p>
&lt;ul>
&lt;li>定义参考值
&lt;ul>
&lt;li>choosing a good reference would rely on domain-specific knowledge, and in some cases it may be best to compute DeepLIFT scores against multiple different references&lt;/li>
&lt;li>比如图像用全0或者模糊版本，基因数据用本底期望频率&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>区分正负贡献（2019）&lt;/li>
&lt;li>贡献度规则
&lt;ul>
&lt;li>线性层直接是系数$w* \Delta x_i$&lt;/li>
&lt;li>非线性变化是$m_{\Delta x\Delta y} = \frac{C_{\Delta x\Delta y}}{\Delta x} =\frac{\Delta y}{\Delta x}$&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="deepshapdeeplift--shapley-value" class="relative group">DeepSHAP(DeepLIFT + Shapley value) &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#deepshapdeeplift--shapley-value" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>尽管kernelSHAP是适用于所有模型的包括深度学习模型的一种可解释方法，但是有没有能利用神经网络特性的可解释方法从而提高计算效率。
DeepLIFT计算的分数近似于Shapley value?并不是这个思路&lt;/p>
&lt;ul>
&lt;li>the Shapely values measure the average marginal effect of including an input over all possible orderings in which inputs can be included. If we define “including” an input as setting it to its actual value instead of its reference value, DeepLIFT can be thought of as a fast approximation of the Shapely values&lt;sup id="fnref:8">&lt;a href="#fn:8" class="footnote-ref" role="doc-noteref">8&lt;/a>&lt;/sup>&lt;/li>
&lt;li>Though a variety of methods exist for estimating SHAP values, we implemented a modified version of the DeepLIFT algorithm, which computes SHAP by estimating differences in model activations during backpropagation relative to a standard reference.
&lt;figure>&lt;img src="https://cdn.jsdelivr.net/gh/jmwyf/pichosting@master/components.png" alt="" class="mx-auto my-0 rounded-md" />
&lt;/figure>
&lt;figure>&lt;img src="https://cdn.jsdelivr.net/gh/jmwyf/pichosting@master/shap.png" alt="" class="mx-auto my-0 rounded-md" />
&lt;/figure>
figure from ref[3]&lt;/li>
&lt;li>基于Shapley value的定义以及公式可以看出重要的一部分即边际效应，即模型包含该特征减去未包含该部分。在上述一个神经网络模块里面，特征顺序选择都不存在。在认为包含特征即相对于参考输入是真实输入的情况下，把包含特征后乘子直接链式法则做为SHAP值近似公式&lt;/li>
&lt;li>在上述简单网络组件里面，输入到输出之间可以看作线性近似从而得到公式16&lt;/li>
&lt;li>把用实际值代替参考值看作是包含某个特征，DeepLIFT方法与DeepSHAP似乎看不到区别?&lt;/li>
&lt;/ul>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>&lt;a href="https://blog.ml.cmu.edu/2020/08/31/6-interpretability/" target="_blank" rel="noreferrer">6 – Interpretability – Machine Learning Blog | ML@CMU | Carnegie Mellon University&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:2">
&lt;p>Ribeiro, M. T., Singh, S. &amp;amp; Guestrin, C. ‘Why Should I Trust You?’: Explaining the Predictions of Any Classifier. &lt;em>Proceedings of the 22nd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining&lt;/em> 1135–1144 (2016) doi:&lt;a href="https://doi.org/10.1145/2939672.2939778" target="_blank" rel="noreferrer">10.1145/2939672.2939778&lt;/a>.&amp;#160;&lt;a href="#fnref:2" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:3">
&lt;p>&lt;a href="https://papers.nips.cc/paper/2017/hash/8a20a8621978632d76c43dfd28b67767-Abstract.html" target="_blank" rel="noreferrer">A Unified Approach to Interpreting Model Predictions&lt;/a>&amp;#160;&lt;a href="#fnref:3" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:4">
&lt;p>&lt;a href="https://christophm.github.io/interpretable-ml-book/shap.html" target="_blank" rel="noreferrer">9.6 SHAP (SHapley Additive exPlanations) | Interpretable Machine Learning&lt;/a>&amp;#160;&lt;a href="#fnref:4" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:5">
&lt;p>&lt;a href="https://libraries.io/pypi/deeplift" target="_blank" rel="noreferrer">deeplift 0.6.13.0 on PyPI - Libraries.io&lt;/a>&amp;#160;&lt;a href="#fnref:5" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:6">
&lt;p>&lt;a href="https://towardsdatascience.com/explainable-neural-networks-recent-advancements-part-3-6a838d15f2fb" target="_blank" rel="noreferrer">Explainable Neural Networks: Recent Advancements, Part 3 | by G Roshan Lal | Towards Data Science&lt;/a>&amp;#160;&lt;a href="#fnref:6" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:7">
&lt;p>Shrikumar, A., Greenside, P., Shcherbina, A. &amp;amp; Kundaje, A. Not Just a Black Box: Learning Important Features Through Propagating Activation Differences. Preprint at &lt;a href="https://doi.org/10.48550/arXiv.1605.01713" target="_blank" rel="noreferrer">https://doi.org/10.48550/arXiv.1605.01713&lt;/a> (2017).&amp;#160;&lt;a href="#fnref:7" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;li id="fn:8">
&lt;p>Shrikumar, A., Greenside, P. &amp;amp; Kundaje, A. Learning Important Features Through Propagating Activation Differences. Preprint at &lt;a href="http://arxiv.org/abs/1704.02685" target="_blank" rel="noreferrer">http://arxiv.org/abs/1704.02685&lt;/a> (2019).&amp;#160;&lt;a href="#fnref:8" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item><item><title>About</title><link>https://youngforever.tech/about/</link><pubDate>Thu, 03 Nov 2022 10:52:00 +0000</pubDate><guid>https://youngforever.tech/about/</guid><description>&lt;p>I am currently an engineer of Center for Artificial Intelligence In Medicine in a Hospital. My research focuses on three areas:&lt;/p>
&lt;ol>
&lt;li>Secondary analysis EHRs&lt;/li>
&lt;li>Wearable device data analysis&lt;/li>
&lt;li>Multimodal fusion learning in healthcare&lt;/li>
&lt;/ol></description></item><item><title>Friends</title><link>https://youngforever.tech/people/</link><pubDate>Fri, 14 Aug 2020 00:00:00 +0000</pubDate><guid>https://youngforever.tech/people/</guid><description>&lt;div class="lead !mb-9 text-xl">
友链以及值得关注的大佬！
&lt;/div>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Website&lt;/th>
&lt;th>Details&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;a href="https://leonis.cc/" target="_blank" rel="noreferrer">Leo&amp;rsquo;s blog&lt;/a>&lt;/td>
&lt;td>数间茅舍，藏书万卷，投老村家&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;a href="https://irenechen.net" target="_blank" rel="noreferrer">Irene Y. Chen &lt;/a>&lt;/td>
&lt;td>Irene study machine learning for equitable healthcare&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;strong>want to be a friend?&lt;/strong> To add your site to this list, please fell free to email me&lt;/p></description></item><item><title>PyTorch深度学习（2）</title><link>https://youngforever.tech/posts/20200401-pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A02/</link><pubDate>Wed, 01 Apr 2020 14:51:32 +0000</pubDate><guid>https://youngforever.tech/posts/20200401-pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A02/</guid><description>
&lt;script>
document.addEventListener("DOMContentLoaded", function() {
renderMathInElement(document.body, {
delimiters: [
{left: '$$', right: '$$', display: true},
{left: '$', right: '$', display: false},
{left: '\\(', right: '\\)', display: false},
{left: '\\[', right: '\\]', display: true}
],
throwOnError : false
});
});
&lt;/script>
&lt;div class="lead !mb-9 text-xl">
Deep Learning = Learning Hierarchical Representations
深度学习即学习层次的表征。
&lt;/div>
&lt;h2 id="1-卷积神经网络" class="relative group">1. 卷积神经网络 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#1-%e5%8d%b7%e7%a7%af%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;h3 id="11-神经网络可视化visualization-of-neural-networks" class="relative group">1.1 神经网络可视化（Visualization of neural networks） &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#11-%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c%e5%8f%af%e8%a7%86%e5%8c%96visualization-of-neural-networks" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>神经网络每一层的操作有点像将空间某些区域进行折叠&lt;/p>
&lt;h3 id="12-卷积神经网络的起源convolutional-neural-networkcnn" class="relative group">1.2 卷积神经网络的起源（Convolutional Neural Network；CNN） &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#12-%e5%8d%b7%e7%a7%af%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c%e7%9a%84%e8%b5%b7%e6%ba%90convolutional-neural-networkcnn" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>受到Fukushima在视觉皮层建模方面的启发，使用简单/复杂的细胞层次结构，结合有监督的训练和反向传播，由Yann LeCun教授于88-89年在多伦多大学开发了第一个CNN。&lt;/p>
&lt;p>Fukushima的工作具体是什么呢？&lt;br>
手写数字识别。首次提出应用多层简单或者复杂的细胞结构建模，特征：手工加无监督聚类学习。无反向传播。&lt;/p>
&lt;h3 id="13-卷积神经网络分解" class="relative group">1.3 卷积神经网络分解 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#13-%e5%8d%b7%e7%a7%af%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c%e5%88%86%e8%a7%a3" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>通用的CNN架构能被分解为以下几个基本结构。&lt;/p>
&lt;ul>
&lt;li>标准化（Normalisation）:对比度标准化等&lt;/li>
&lt;li>滤波器组（Filter banks）:边缘检测等&lt;/li>
&lt;li>非线性化（Non-linearities）:稀疏化、ReLU等&lt;/li>
&lt;li>池化（pooling）:最大池化（max pooling）等&lt;/li>
&lt;/ul>
&lt;h2 id="2-自然信号数据natural-signals" class="relative group">2. 自然信号数据（Natural Signals） &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#2-%e8%87%aa%e7%84%b6%e4%bf%a1%e5%8f%b7%e6%95%b0%e6%8d%aenatural-signals" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;h3 id="21-自然信号数据特性" class="relative group">2.1 自然信号数据特性 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#21-%e8%87%aa%e7%84%b6%e4%bf%a1%e5%8f%b7%e6%95%b0%e6%8d%ae%e7%89%b9%e6%80%a7" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>周期性：在时域很多模式都会重复出现&lt;/li>
&lt;li>局部性：相邻的点较相远的点来说更具关联性&lt;/li>
&lt;li>合成性：复杂的事物可以由简单的事物组合而成。字母-&amp;gt;单词-&amp;gt;句子-&amp;gt;文章&lt;/li>
&lt;/ul>
&lt;h3 id="22-对应神经网络中的处理方法" class="relative group">2.2 对应神经网络中的处理方法 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#22-%e5%af%b9%e5%ba%94%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c%e4%b8%ad%e7%9a%84%e5%a4%84%e7%90%86%e6%96%b9%e6%b3%95" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ul>
&lt;li>周期性$\rightarrow$参数共享&lt;br>
如果数据存在周期性，可以使用参数共享，即卷积核。&lt;/li>
&lt;li>局部性$\rightarrow$稀疏&lt;br>
如果数据存在局部性，那么每个神经元只需要与前几个神经元连接&lt;/li>
&lt;li>合成性$\rightarrow$多层&lt;br>
即神经网络中多层网络合成最终的结果&lt;/li>
&lt;/ul>
&lt;h2 id="3-pytorch实现mnist手写字识别" class="relative group">3. Pytorch实现Mnist手写字识别 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#3-pytorch%e5%ae%9e%e7%8e%b0mnist%e6%89%8b%e5%86%99%e5%ad%97%e8%af%86%e5%88%ab" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># load package and data&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">torch&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">torch.nn&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">nn&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">torch.nn.functional&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">F&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">torch.optim&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">optim&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">torchvision&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">datasets&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">transforms&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">matplotlib.pyplot&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">plt&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">device&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">torch&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">device&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;cuda:0&amp;#34;&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">torch&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">cuda&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">is_available&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="s2">&amp;#34;cpu&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 神经网络模型偏爱标准化数据，原因是均值为0方差为1的数据在sigmoid、tanh经过激活函数后求导得到的导数很大，&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 反之原始数据不仅分布不均（噪声大）而且数值通常都很大（本例中数值范围是0~255），激活函数后求导得到的导数&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 则接近与0，这也被称为梯度消失。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 目录放自己下载好的mnist目录，没有下载将download=True,自己新建一个存放数据目录即可&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">train_loader&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">torch&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">utils&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">DataLoader&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">datasets&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">MNIST&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;../LSTM_mnist/mnist&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">train&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">download&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">transform&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">transforms&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Compose&lt;/span>&lt;span class="p">([&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">transforms&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">ToTensor&lt;/span>&lt;span class="p">(),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># mnist数据集均值0.1307，标准差0.3081&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">transforms&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Normalize&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="mf">0.1307&lt;/span>&lt;span class="p">,),&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mf">0.3081&lt;/span>&lt;span class="p">,))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">])),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">batch_size&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">64&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">shuffle&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">test_loader&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">torch&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">utils&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">DataLoader&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">datasets&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">MNIST&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;../LSTM_mnist/mnist&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">train&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">transform&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">transforms&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Compose&lt;/span>&lt;span class="p">([&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">transforms&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">ToTensor&lt;/span>&lt;span class="p">(),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">transforms&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Normalize&lt;/span>&lt;span class="p">((&lt;/span>&lt;span class="mf">0.1307&lt;/span>&lt;span class="p">,),&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="mf">0.3081&lt;/span>&lt;span class="p">,))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="p">])),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">batch_size&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1000&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">shuffle&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># define model&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">SimpleCNN&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nn&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Module&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">input_size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n_feature&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">output_size&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">super&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">SimpleCNN&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="fm">__init__&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">n_feature&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">n_feature&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 关于nn.Conv2d()中参数的解释&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># in_channels (int): Number of channels in the input image&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># out_channels (int): Number of channels produced by the convolution&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># kernel_size (int or tuple): Size of the convolving kernel&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># default stride=1, padding=0, dilation=1, groups=1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># [groupsc参数详解](https://www.jianshu.com/p/20ba3d8f283c)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># [图解卷积神经网络中stride, padding等操作可视化](https://github.com/vdumoulin/conv_arithmetic)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># input: (N, C_in, H_in, W_in)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">conv1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nn&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Conv2d&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">in_channels&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">out_channels&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">n_feature&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">kernel_size&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">conv2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nn&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Conv2d&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n_feature&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n_feature&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">kernel_size&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fc1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nn&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Linear&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">n_feature&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">50&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fc2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nn&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Linear&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">50&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">forward&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">conv1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># Mnist数据原始大小（28*28）28-5+1 = 24 (24*24*n_feature)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">F&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">relu&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">F&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">max_pool2d&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">kernel_size&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># (12*12*n_feature)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">conv2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># 12-5+1 = 8 (8*8*n_feature)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">F&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">relu&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">F&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">max_pool2d&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">kernel_size&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># (4*4*n_feature)这里解释了上面全连接时为啥是4*4&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">view&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">n_feature&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fc1&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">F&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">relu&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fc2&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">F&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">log_softmax&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">dim&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">x&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># hyper parameters&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">epochs&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">input_size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">28&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="mi">28&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">output_size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">n_features&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">6&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">lr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.01&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">model&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">SimpleCNN&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">input_size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">n_features&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">output_size&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">model&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">to&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">device&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># optimizer&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">optimizer&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">optim&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">SGD&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">parameters&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">lr&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">momentum&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mf">0.5&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Number of parameters: &lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s1">&amp;#39;&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">format&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">get_n_params&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="p">)))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># model train&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="n">epoch&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">epochs&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">model&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">train&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">target&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">enumerate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">train_loader&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">data&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">target&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">to&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">device&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">target&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">to&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">device&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">output&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">model&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">loss&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">F&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">nll_loss&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">target&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">optimizer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">zero_grad&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">loss&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">backward&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">optimizer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">step&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="mi">100&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Train Epoch [&lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s1">/&lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s1">], [&lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s1">/&lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s1"> (&lt;/span>&lt;span class="si">{:.0f}&lt;/span>&lt;span class="s1">%)], Loss: &lt;/span>&lt;span class="si">{:.4f}&lt;/span>&lt;span class="s1">&amp;#39;&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">format&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">epoch&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">epochs&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">train_loader&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">dataset&lt;/span>&lt;span class="p">),&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="mi">100&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">train_loader&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">loss&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="p">()))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># model eval&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">model&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">eval&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">test_loss&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">correct&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">accuracy_list&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[]&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">target&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">test_loader&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">data&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">target&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">data&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">to&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">device&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">target&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">to&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">device&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">output&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">model&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">test_loss&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">F&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">nll_loss&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">output&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">target&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">reduction&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;sum&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">pred&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">output&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">keepdim&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">)[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1"># get the index of the max log-probability&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">correct&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">pred&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">eq&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">target&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">view_as&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">pred&lt;/span>&lt;span class="p">))&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">cpu&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sum&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">test_loss&lt;/span> &lt;span class="o">/=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">test_loader&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">dataset&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">accuracy&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">100.&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">correct&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">test_loader&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">dataset&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">accuracy_list&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">accuracy&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s1">Test set Average loss: &lt;/span>&lt;span class="si">{:.4f}&lt;/span>&lt;span class="s1">, Accuracy: &lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s1">/&lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s1"> (&lt;/span>&lt;span class="si">{:.0f}&lt;/span>&lt;span class="s1">%)&lt;/span>&lt;span class="se">\n&lt;/span>&lt;span class="s1">&amp;#39;&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">format&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">test_loss&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">correct&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">test_loader&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">dataset&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="n">accuracy&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 几个预测的实例可视化&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">plt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">subplot&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">plt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">imshow&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">plt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">title&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;Prediction: &lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">format&lt;/span>&lt;span class="p">(&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">output&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">keepdim&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">)[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="p">()))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">plt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">show&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>
&lt;figure>&lt;img src="https://youngforever.tech/images/pytorch/mnist_pre.png" alt="" class="mx-auto my-0 rounded-md" />
&lt;/figure>
&lt;/p>
&lt;h2 id="4-补充" class="relative group">4. 补充 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#4-%e8%a1%a5%e5%85%85" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ol>
&lt;li>可以做一个有趣的实验即打乱图片中的像素后CNN识别正确率下降，而全连接网络则不会，即与最开始提到的三个特性以及对于神经网络采取的假设是吻合的。&lt;/li>
&lt;li>参考2中是对卷积神经网络全面的介绍，包括CNN中常用那些层，以及常用的模型和参数多少计算。&lt;/li>
&lt;/ol>
&lt;h2 id="ref" class="relative group">ref &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#ref" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ol>
&lt;li>&lt;a href="https://atcold.github.io/pytorch-Deep-Learning/" target="_blank" rel="noreferrer">NYC PyTorch Deep Learning&lt;/a>课程网站&lt;/li>
&lt;li>cs231n &lt;a href="https://cs231n.github.io/convolutional-networks/" target="_blank" rel="noreferrer">convolutional networks&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pytorch.org/docs/stable/nn.html#convolution-layers" target="_blank" rel="noreferrer">pytorch官方文档Conv2d&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/Atcold/pytorch-Deep-Learning/blob/master/06-convnet.ipynb" target="_blank" rel="noreferrer">课程convnet.ipynb&lt;/a>&lt;/li>
&lt;/ol></description></item><item><title>重读XGBoost</title><link>https://youngforever.tech/posts/20200323-%E9%87%8D%E8%AF%BBxgboost/</link><pubDate>Mon, 23 Mar 2020 16:18:13 +0000</pubDate><guid>https://youngforever.tech/posts/20200323-%E9%87%8D%E8%AF%BBxgboost/</guid><description>
&lt;script>
document.addEventListener("DOMContentLoaded", function() {
renderMathInElement(document.body, {
delimiters: [
{left: '$$', right: '$$', display: true},
{left: '$', right: '$', display: false},
{left: '\\(', right: '\\)', display: false},
{left: '\\[', right: '\\]', display: true}
],
throwOnError : false
});
});
&lt;/script>
&lt;p>在使用xgboost方法调参时，对其中个别参数不是特别理解。故重新读了一遍原论文。&lt;/p>
&lt;h2 id="1-引言" class="relative group">1. 引言 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#1-%e5%bc%95%e8%a8%80" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>阐述机器学习和数据驱动的方法应用时两个重要的因素：&lt;/p>
&lt;ul>
&lt;li>能捕捉数据间复杂依赖关系的模型&lt;/li>
&lt;li>可扩展的学习系统，可以从大量数据中学习&lt;/li>
&lt;/ul>
&lt;p>在目前常用的方法中，梯度提升树（gradient tree boosting）在许多场景中效果都不错，作者列举了一些。提出xgboost方法在比赛以及各类问题中的应用。&lt;/p>
&lt;p>叙述XGBoost的优点：运行更快、拓展性更好。创新点包括：&lt;/p>
&lt;ul>
&lt;li>高度可拓展的端到端提升树（tree boosting）系统&lt;/li>
&lt;li>用于高效计算的加权分位数图（weighted quantile sketch）&lt;/li>
&lt;li>新颖的稀疏感知算法（sparsity-aware algorithm），用于并行树学习&lt;/li>
&lt;li>有效的缓存优化以及块（cache-aware block）结构用于外存（out-of-core）树学习
关于以上几点在正文中详解。&lt;/li>
&lt;/ul>
&lt;p>论文结构：&lt;/p>
&lt;ol>
&lt;li>提升树（tree boosting）简介以及目标函数正则化&lt;/li>
&lt;li>分裂点寻找的方法&lt;/li>
&lt;li>系统设计，包括为每个优化提供量化支持的结果&lt;/li>
&lt;li>相关工作&lt;/li>
&lt;li>详细的端到端评估&lt;/li>
&lt;li>总结&lt;/li>
&lt;/ol>
&lt;h2 id="2-提升树tree-boosting简介" class="relative group">2. 提升树（Tree Boosting）简介 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#2-%e6%8f%90%e5%8d%87%e6%a0%91tree-boosting%e7%ae%80%e4%bb%8b" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>首先需要了解CART（Classification And Regression Tree）算法，对于cart分类树和回归树分别采用了：&lt;code>Gini系数&lt;/code>、&lt;code>和方差&lt;/code>度量方式来划分节点[1]。例如回归树，对于划分特征A, 划分点s使两边数据集D1和D2,求出使
D1和D2各自集合的均方差最小，同时D1和D2的均方差之和最小。
$$\underline{min}_{\text{A,s}}[\underline{min}_{\text{c1}}\sum_{x_i\in{D1(A,s)}}(y_i - c1)^2+\underline{min}_{\text{c2}}\sum_{x_i\in{D2(A,s)}}(y_i - c2)^2]$$
其中，c1为D1的样本输出均值，c2为D2的样本输出均值, 回归树采用叶子节点的均值或者中位数来预测输出结果，$y_i$即样本的label，此时的输出值即下文中用到的$w_{q(x)}$。&lt;/p>
&lt;h3 id="21-正则化目标函数" class="relative group">2.1 正则化目标函数 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#21-%e6%ad%a3%e5%88%99%e5%8c%96%e7%9b%ae%e6%a0%87%e5%87%bd%e6%95%b0" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>对于这种类型的集成树模型，用K棵树的结果来预测最后的结果（式1），那么问题来了我们怎么来求这些树的参数，每棵树都可以看做一个函数$f_i$包含树的结构以及最后叶节点权重，集成模型不像传统优化问题一样通过简单用梯度下降可以对所有的树进行学习求解，所以，在这里用到了加法策略，即固定已经学习到的，每次加一棵树来进行学习（式3）。
$$\hat{y_i} = \phi(x_i) = \sum_{k = 1}^{K} f_k(x_i)\tag1$$
其中$f(x) = w_{q(x)}$，每个$f_k$对应一个独立的树结构q以及其叶节点权重w，为了学习模型中的参数，最小化下面正则化的目标函数。
$$L(\phi) = \sum_i l(\hat{y_i}, y_i) + \sum_k \Omega(f_k)\tag2$$&lt;/p>
&lt;p>$$\Omega(f_k) = \gamma T + \frac{1}{2}\lambda||w||^2$$
T是树的叶节点数&lt;/p>
&lt;h3 id="22-梯度提升树gradient-tree-boosting" class="relative group">2.2 梯度提升树（Gradient Tree Boosting） &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#22-%e6%a2%af%e5%ba%a6%e6%8f%90%e5%8d%87%e6%a0%91gradient-tree-boosting" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>第t次预测值等于t-1加上第t棵树的结果
$$\hat{y_i} = \hat{y_i}^{t-1} + f_t(x_i)\tag3$$
此时目标函数(式2)可以写成
$$L^{(t)} = \sum_{i=1} ^n l(y_i, \hat{y_i}^{(t-1)}+f_t(x_i)) + \Omega(f_t)\tag4$$
该式子的二阶近似可以表达为(式5），可以参考补充中&lt;a href="#taylor">二阶泰勒展开的一般形式&lt;/a>
$$L^{(t)} \approx \sum_{i=1} ^n [l(y_i, \hat{y_i}^{(t-1)}) + g_if_t(x_i) + \frac{1}{2}h_if_t^2(x_i)]+\Omega(f_t)\tag5$$
其中 $g_i=\partial_{\hat{y}^{(t-1)}}{l(y_i, \hat{y_i}^{(t-1)})}， h_i=\partial_{\hat{y}^{(t-1)}}^2{l(y_i, \hat{y_i}^{(t-1)})}$&lt;/p>
&lt;p>式5中去掉常数项，即label与第t-1次结果的损失函数，可以得到：&lt;/p>
&lt;p>$$\sum_{i=1}^n[g_if_t(x_i)+\frac{1}{2}h_if_t^2(x_i)]+\Omega(f_t)\tag6$$&lt;/p>
&lt;p>式6即对新树的优化目标函数，进一步合并可以写为：&lt;/p>
&lt;p>$$obj^{t} \approx \sum_{i=1}^{n}[g_i w_{q(x_i)} + \frac{1}{2}h_i w^2_{q(x_i)}] + \gamma T+ \frac{1}{2}\lambda \sum _{j=1}^T w_j^2$$&lt;/p>
&lt;p>定义$I_j = {i|q(x_i)=j}$即叶节点j上的实例。&lt;/p>
&lt;p>$$obj^{t} \approx \sum_{j=1}^T[(\sum_{i\in{I_j}}g_i)w_j+\frac{1}{2}(\sum_{i\in{I_j}}h_i+\lambda)w_j^2]+\gamma T\tag7$$&lt;/p>
&lt;p>上式7对$w_j$求导即可求出w最优值&lt;/p>
&lt;p>$$w_j^* = -\frac{\sum_{i\in{I_j}}g_i}{\sum_{i\in{I_j}}h_i+\lambda} $$&lt;/p>
&lt;p>令$G_j = \sum_{i\in{I_j}}g_i，H_j=\sum_{i\in{I_j}}h_i$&lt;/p>
&lt;p>此时，对应的最小值为:
$$obj^* = -\frac{1}{2}\sum_{j=1}^T\frac{G_j^2}{H_j+\lambda}+\gamma T$$
$\color{red}\frac{G_j^2}{H_j+\lambda}$越大，loss越小，所以对叶节点进行分裂，分裂后增益定义为
$$Gain=\frac{1}{2}[\frac{G_L^2}{H_L+\lambda}+\frac{G_R^2}{H_R+\lambda}-\frac{(G_L+G_R)^2}{H_L+H_R+\lambda}]-\gamma\tag8$$&lt;/p>
&lt;h3 id="23-缩减和列抽样shrinkage-and-column-subsampling" class="relative group">2.3 缩减和列抽样（Shrinkage and Column Subsampling） &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#23-%e7%bc%a9%e5%87%8f%e5%92%8c%e5%88%97%e6%8a%bd%e6%a0%b7shrinkage-and-column-subsampling" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>除了在目标函数中引入正则项，在防止过拟合方面xgboost还运用了两项技术，给每一步tree boosting得到的结果一个权重$\eta$，来降低每一步的影响从而给后面树的形成留下空间，比喻成优化问题中的学习率缩减；同时还用到随机森林中的列抽样，即随机特征筛选。&lt;/p>
&lt;h2 id="3-分裂点寻找算法" class="relative group">3. 分裂点寻找算法 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#3-%e5%88%86%e8%a3%82%e7%82%b9%e5%af%bb%e6%89%be%e7%ae%97%e6%b3%95" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;h3 id="31-精确贪婪算法basic-exact-greedy-algorithm" class="relative group">3.1 精确贪婪算法（Basic Exact Greedy Algorithm） &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#31-%e7%b2%be%e7%a1%ae%e8%b4%aa%e5%a9%aa%e7%ae%97%e6%b3%95basic-exact-greedy-algorithm" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>即按照2.2中式8来寻找分裂点
python&lt;code>scikit-learn&lt;/code>，R&lt;code>gbm&lt;/code>，单机的xgboost都支持。&lt;/p>
&lt;div align=center>
&lt;img src="https://youngforever.tech/images/xgboost/algorithm1.jpg" width=50% heigth=50% />
&lt;/div>
&lt;!-- ![Algorithm1](/images/xgboost/algorithm1.jpg) -->
&lt;h3 id="32-近似算法approximate-algorithm" class="relative group">3.2 近似算法（Approximate Algorithm） &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#32-%e8%bf%91%e4%bc%bc%e7%ae%97%e6%b3%95approximate-algorithm" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>精确贪婪算法由于列举了所有可能的分裂点，在数据量很大不能全部写入内存时会导致不是那么高效。所以提出近似算法。对于每个特征，只考察分位点，减少计算复杂度。
近似算法存在两个变种：&lt;/p>
&lt;ul>
&lt;li>global: 学习每棵树前，提出候选分裂点&lt;/li>
&lt;li>local: 每次分裂前，重新提出候选分裂点&lt;/li>
&lt;/ul>
&lt;div align=center>
&lt;img src="https://youngforever.tech/images/xgboost/algorithm2.jpg" width=50% heigth=50% />
&lt;/div>
&lt;!-- ![Algorithm2](/images/xgboost/algorithm2.jpg) -->
&lt;h3 id="33-加权分位数图weighted-quantile-sketch" class="relative group">3.3 加权分位数图（Weighted Quantile Sketch） &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#33-%e5%8a%a0%e6%9d%83%e5%88%86%e4%bd%8d%e6%95%b0%e5%9b%beweighted-quantile-sketch" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>近似算法中最重要一点即提出候选分裂点，xgboost不是简单的按照样本个体进行分位，而是以损失函数二阶导数值作为权重进行分位数分裂。如何寻找二阶导数分位点，首先是利用权重计算排序函数，然后相邻相减值作为判断依据。问题是为什么会想到利用损失函数二阶导数值作为权重来划分。
文中给出式6可以变形为
$$\sum_{i=1}^n\frac{1}{2}h_i(f_t(x_i)-g_i/h_i)^2 + \Omega(f_t) + constant\tag9$$
指出该式恰好是权重平方差损失函数，权重$h_i$以及label $g_i/h_i$
自己从式6变不到式9，觉得中间符号是+还差不多。
看有人理解说变成式10才对。是否作者真的是这样想的，不得而知。欢迎指正。
$$\sum_{i=1}^n\frac{1}{2}h_i(f_t(x_i)-(-g_i/h_i))^2 + \Omega(f_t) + constant\tag{10}$$
&lt;a href="https://datascience.stackexchange.com/questions/10997/need-help-understanding-xgboosts-approximate-split-points-proposal" target="_blank" rel="noreferrer">stackexchange上关于理解xgboost近似分裂点&lt;/a>&lt;/p>
&lt;h3 id="34-稀疏值感知分裂sparsity-aware-split-finding" class="relative group">3.4 稀疏值感知分裂（Sparsity-aware split finding） &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#34-%e7%a8%80%e7%96%8f%e5%80%bc%e6%84%9f%e7%9f%a5%e5%88%86%e8%a3%82sparsity-aware-split-finding" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>造成稀疏值的原因：1）缺失值 2）统计过程中频繁的0值输入 3）one-hot编码以及其他特征工程
所以让算法注意数据中稀疏规律很重要，遍历所有特征，在划分子节点时，统一将该特征的缺失值划分到右支或者左支，计算最大的gain。&lt;/p>
&lt;div align=center>
&lt;img src="https://youngforever.tech/images/xgboost/Sparsity.jpg" width=50% heigth=50% />
&lt;/div>
&lt;!-- ![Sparsity](/images/xgboost/Sparsity.jpg) -->
&lt;p>$\color{red}这里也有个疑问就是为什么排序第一次是升序，第二次是降序$&lt;/p>
&lt;h2 id="4-系统设计" class="relative group">4. 系统设计 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#4-%e7%b3%bb%e7%bb%9f%e8%ae%be%e8%ae%a1" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;h3 id="41-分块并行column-block-for-parallel-learning" class="relative group">4.1 分块并行（Column Block for Parallel Learning） &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#41-%e5%88%86%e5%9d%97%e5%b9%b6%e8%a1%8ccolumn-block-for-parallel-learning" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>基于树学习过程中最耗时的是将数据排序，为了减少排序的时间成本，提出基于内存的block结构。&lt;/p>
&lt;ul>
&lt;li>在Exact greedy算法中，将整个数据集存放在一个Block中&lt;/li>
&lt;li>在近似算法中，使用多个Block，每个Block对应原来数据的子集。不同的Block可以在不同的机器上并行计算&lt;/li>
&lt;/ul>
&lt;h3 id="42-缓存优化" class="relative group">4.2 缓存优化 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#42-%e7%bc%93%e5%ad%98%e4%bc%98%e5%8c%96" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>这里指利用CPU缓存对算法进行优化。&lt;/p>
&lt;p>4.1中column block按特征大小顺序存储，相应的样本的梯度信息是分散的，造成内存的不连续访问，降低CPU cache命中率。
优化方法：&lt;/p>
&lt;ul>
&lt;li>对于精确贪婪算法，预取数据到buffer中（非连续-&amp;gt;连续），再统计梯度信息。&lt;/li>
&lt;li>对于近似算法，调节block的大小，设置过大则容易导致命中率低，过小则容易导致并行化效率不高。&lt;/li>
&lt;/ul>
&lt;h3 id="43-外存计算" class="relative group">4.3 外存计算 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#43-%e5%a4%96%e5%ad%98%e8%ae%a1%e7%ae%97" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>除了处理器以及内存，利用磁盘空间来处理不能进入内存的数据也十分重要，数据划分为多个Block并存放在磁盘上。计算的时候，使用独立的线程预先将Block放入主内存，因此可以在计算的同时读取磁盘。在减少计算资源开销以及提高磁盘输入输出方面主要用到以下技术：&lt;/p>
&lt;ul>
&lt;li>Block压缩，按列压缩，加载到主内存时由独立线程动态解压缩。具体压缩技术参看原文。&lt;/li>
&lt;li>Block Sharding，将数据划分到不同硬盘上，提高磁盘吞吐率。&lt;/li>
&lt;/ul>
&lt;h2 id="5-端到端评估" class="relative group">5. 端到端评估 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#5-%e7%ab%af%e5%88%b0%e7%ab%af%e8%af%84%e4%bc%b0" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>利用4个数据集对xgboost评估：&lt;/p>
&lt;ul>
&lt;li>分类问题&lt;/li>
&lt;li>排序问题&lt;/li>
&lt;li>外存计算实验&lt;/li>
&lt;li>分布计算实验&lt;/li>
&lt;/ul>
&lt;p>这几个方面进行评估，详细结果见论文。&lt;/p>
&lt;h2 id="ref" class="relative group">ref &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#ref" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ol>
&lt;li>&lt;a href="https://blog.csdn.net/hy592070616/article/details/81628956" target="_blank" rel="noreferrer">CART分类树与回归树&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.cnblogs.com/xym4869/p/11282586.html" target="_blank" rel="noreferrer">Markdown数学公式&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.mathjax.org/en/latest/web/configuration.html" target="_blank" rel="noreferrer">Mathjax应用在网页&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://homes.cs.washington.edu/~tqchen/pdf/BoostedTree.pdf" target="_blank" rel="noreferrer">XGBoost.ppt&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://xgboost.readthedocs.io/en/latest/tutorials/model.html" target="_blank" rel="noreferrer">readthedocs xgboost tutorials&lt;/a>推荐&lt;/li>
&lt;li>&lt;a href="http://wepon.me/files/gbdt.pdf" target="_blank" rel="noreferrer">gbdt.ppt&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://arxiv.org/abs/1603.02754" target="_blank" rel="noreferrer">xgboost原文&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="补充" class="relative group">补充 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%a1%a5%e5%85%85" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ol>
&lt;li>文中很多术语翻译可能有不恰当的地方，欢迎指出。&lt;/li>
&lt;li>二阶泰勒展开的一般形式：
$$f(x^t) = f(x^{t-1}+\Delta x)\approx{f(x^{t-1})+ f^{\prime}(x^{t-1})\Delta{x}+f^{\prime\prime}(x^{t-1})\frac{\Delta x^2}{2}}$$&lt;/li>
&lt;li>式4中加入loss function是mean squared error(MSE)，可以求出相应的gi， hi作为一个特例来验证该做法。&lt;/li>
&lt;li>基于树的算法理解时带着这几个问题去理解每一步是用来做什么的：选择哪个特征进行分裂？在特征什么点位进行分裂？分裂后叶节点取什么值？
&lt;blockquote>
&lt;p>分别对应：遍历每个特征，加权分位数图，$w_j$&lt;/p>
&lt;/blockquote>
&lt;/li>
&lt;li>对于系统设计中应用到的技术理解不是十分深刻，对应一个算法如何从计算机硬件的方方面面考虑去优化对非专业领域研究者还是比较难&lt;/li>
&lt;/ol></description></item><item><title>LSTM应用场景以及pytorch实例</title><link>https://youngforever.tech/posts/20200307-lstm%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</link><pubDate>Mon, 09 Mar 2020 15:07:13 +0000</pubDate><guid>https://youngforever.tech/posts/20200307-lstm%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</guid><description>
&lt;script>
document.addEventListener("DOMContentLoaded", function() {
renderMathInElement(document.body, {
delimiters: [
{left: '$$', right: '$$', display: true},
{left: '$', right: '$', display: false},
{left: '\\(', right: '\\)', display: false},
{left: '\\[', right: '\\]', display: true}
],
throwOnError : false
});
});
&lt;/script>
&lt;p>在去年介绍的一篇paper中，应用了多任务RNN来解决问题，当时RNN指的即是LSTM。本文介绍LSTM实现以及应用。&lt;/p>
&lt;h2 id="1-lstm简介" class="relative group">1. LSTM简介 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#1-lstm%e7%ae%80%e4%bb%8b" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>循环神经网络要点在于可以将上一时刻的信息传递给下一时刻，但是在需要长程信息依赖的场景，训练一个好的RNN十分困难，存在梯度爆炸和梯度消失的情况。LSTM通过刻意的设计来解决该问题。&lt;/p>
&lt;p>简单的RNN网络中重复的模块只有一个简单的结构，例如一个&lt;code>relu&lt;/code>层，而在LSTM中重复的模块拥有4个不同的结构相互交互来完成。&lt;/p>
&lt;p>
&lt;figure>&lt;img src="https://youngforever.tech/images/LSTM/LSTM.jpg" alt="LSTM" class="mx-auto my-0 rounded-md" />
&lt;/figure>
&lt;/p>
&lt;h3 id="11-首先决定从cell中丢弃什么信息" class="relative group">1.1 首先决定从cell中丢弃什么信息 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#11-%e9%a6%96%e5%85%88%e5%86%b3%e5%ae%9a%e4%bb%8ecell%e4%b8%ad%e4%b8%a2%e5%bc%83%e4%bb%80%e4%b9%88%e4%bf%a1%e6%81%af" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>$$f_t = \sigma(W_f*[h_{t-1}, X_t] + b_f) \tag1$$
sigma函数在0到1选择代表丢弃与否&lt;/p>
&lt;h3 id="12-什么样的新信息存放到cell中" class="relative group">1.2 什么样的新信息存放到cell中 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#12-%e4%bb%80%e4%b9%88%e6%a0%b7%e7%9a%84%e6%96%b0%e4%bf%a1%e6%81%af%e5%ad%98%e6%94%be%e5%88%b0cell%e4%b8%ad" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>$$i_t = \sigma(W_i*[h_{t-1}, x_t] + b_i) \tag2$$&lt;/p>
&lt;p>$$\widetilde{C_t} = tanh(W_c*[h_{t-1}, x_t] + b_c) \tag3$$&lt;/p>
&lt;p>$$C_t = f_t*C_{t-1} + {i_t} * \widetilde{C_{t}} \tag4$$&lt;/p>
&lt;p>4式中旧状态与$f_t$相乘，丢弃确定需要丢弃的信息，加上新的候选值。可以看到假如遗忘门一直为1，就可以保持以前的信息$C_{t-1}$&lt;/p>
&lt;h3 id="13-输出结果" class="relative group">1.3 输出结果 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#13-%e8%be%93%e5%87%ba%e7%bb%93%e6%9e%9c" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>$$o_t = \sigma(W_o[h_{t-1}, x_t] + b_o)\tag5$$
$$h_t = o_t*tanh(C_t)\tag6$$&lt;/p>
&lt;h2 id="2-lstm实例以及pytorch实现" class="relative group">2. LSTM实例以及Pytorch实现 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#2-lstm%e5%ae%9e%e4%be%8b%e4%bb%a5%e5%8f%8apytorch%e5%ae%9e%e7%8e%b0" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>循环神经网络可以应用到以下场景。&lt;/p>
&lt;p>
&lt;figure>&lt;img src="https://youngforever.tech/images/LSTM/examples.jpg" alt="examples" class="mx-auto my-0 rounded-md" />
&lt;/figure>
&lt;/p>
&lt;ul>
&lt;li>点对点（单个图片（文字）被分类；图像分类）&lt;/li>
&lt;li>点对序列（单个图像（文字）被分为多个类；图像输出文字）&lt;/li>
&lt;li>序列分析（一系列图片（文字）被分类；情感分析）&lt;/li>
&lt;li>不等长序列对序列（机器翻译）&lt;/li>
&lt;li>等长序列对序列（视频帧分类）&lt;/li>
&lt;/ul>
&lt;p>举两个例子：图像分类以及时间序列预测&lt;/p>
&lt;h3 id="21-lstm图像分类" class="relative group">2.1 LSTM图像分类 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#21-lstm%e5%9b%be%e5%83%8f%e5%88%86%e7%b1%bb" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>关于图片分类常用卷积神经网络，侧重空间上处理；而循环神经网络侧重序列处理。但是也能用来图片分类。第一个例子以常用的mnist手写字体识别为例。&lt;/p>
&lt;h4 id="211-导入所需用到的包以及超参数设置等" class="relative group">2.1.1 导入所需用到的包以及超参数设置等 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#211-%e5%af%bc%e5%85%a5%e6%89%80%e9%9c%80%e7%94%a8%e5%88%b0%e7%9a%84%e5%8c%85%e4%bb%a5%e5%8f%8a%e8%b6%85%e5%8f%82%e6%95%b0%e8%ae%be%e7%bd%ae%e7%ad%89" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Setup&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">torch&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">torch&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">nn&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">from&lt;/span> &lt;span class="nn">torch.utils.data&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="n">DataLoader&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">torchvision.datasets&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">dsets&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="kn">import&lt;/span> &lt;span class="nn">torchvision.transforms&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="nn">transforms&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">torch&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">manual_seed&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Device configuration&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">device&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">torch&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">device&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;cuda&amp;#39;&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="n">torch&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">cuda&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">is_available&lt;/span>&lt;span class="p">()&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="s1">&amp;#39;cpu&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="212-导入数据集" class="relative group">2.1.2 导入数据集 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#212-%e5%af%bc%e5%85%a5%e6%95%b0%e6%8d%ae%e9%9b%86" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Mnist手写数字&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">train_data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">dsets&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">MNIST&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;./mnist/&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1"># 保存或者提取位置&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">train&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1"># this is tra`ining data&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">transform&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">transforms&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">ToTensor&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="c1"># 转换 PIL.Image or numpy.ndarray 成&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># torch.FloatTensor (C x H x W), 训练的时候 normalize 成 [0.0, 1.0] 区间&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">download&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="c1"># 没下载就下载, 下载了就不用再下了改成False&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">test_data&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">dsets&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">MNIST&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="s1">&amp;#39;./mnist/&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">train&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">False&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">transform&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">transforms&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">ToTensor&lt;/span>&lt;span class="p">())&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Dataloader&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># PyTorch中数据读取的一个重要接口，该接口定义在dataloader.py中，只要是用PyTorch来训练模型基本都会用到该接口（除非用户重写…），&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 该接口的目的：将自定义的Dataset根据batch size大小、是否shuffle等封装成一个Batch Size大小的Tensor，用于后面的训练。&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">train_loader&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">DataLoader&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dataset&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">train_data&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">batch_size&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">batch_size&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">shuffle&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># 在每个epoch开始的时候，对数据重新打乱进行训练。在这里其实没啥用，因为只训练了一次&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">test_loader&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">DataLoader&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">dataset&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">test_data&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">batch_size&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">batch_size&lt;/span>&lt;span class="p">,&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">shuffle&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">False&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="213-建立模型" class="relative group">2.1.3 建立模型 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#213-%e5%bb%ba%e7%ab%8b%e6%a8%a1%e5%9e%8b" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># LSTM&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># __init__ is basically a function which will &amp;#34;initialize&amp;#34;/&amp;#34;activate&amp;#34; the properties of the class for a specific object&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># self represents that object which will inherit those properties&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">class&lt;/span> &lt;span class="nc">simpleLSTM&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">nn&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Module&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">input_size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">hidden_size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_layers&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_classes&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">super&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">simpleLSTM&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="fm">__init__&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">hidden_size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">hidden_size&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">num_layers&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">num_layers&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">lstm&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nn&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">LSTM&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">input_size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">hidden_size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_layers&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">batch_first&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="kc">True&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fc&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nn&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Linear&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">hidden_size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_classes&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">def&lt;/span> &lt;span class="nf">forward&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># x shape (batch, time_step, input_size)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># out shape (batch, time_step, output_size)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># h_n shape (n_layers, batch, hidden_size)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># h_c shape (n_layers, batch, hidden_size)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 初始化hidden和memory cell参数&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">h0&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">torch&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">zeros&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">num_layers&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">hidden_size&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">to&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">device&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">c0&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">torch&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">zeros&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">num_layers&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">hidden_size&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">to&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">device&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># forward propagate lstm&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">out&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">h_n&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">h_c&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">lstm&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">h0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">c0&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># 选取最后一个时刻的输出&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">out&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fc&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">out&lt;/span>&lt;span class="p">[:,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">:])&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">return&lt;/span> &lt;span class="n">out&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">model&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">simpleLSTM&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">input_size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">hidden_size&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_layers&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">num_classes&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># loss and optimizer&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">criterion&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nn&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">CrossEntropyLoss&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">optimizer&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">torch&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">optim&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Adam&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">model&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">parameters&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">lr&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="214-训练模型" class="relative group">2.1.4 训练模型 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#214-%e8%ae%ad%e7%bb%83%e6%a8%a1%e5%9e%8b" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># train the model&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 关于reshape(-1)的解释 https://www.zhihu.com/question/52684594&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># view()和reshape()区别的解释 https://stackoverflow.com/questions/49643225/whats-the-difference-between-reshape-and-view-in-pytorch&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Hyper Parameters&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">epochs&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span> &lt;span class="c1"># 训练整批数据多少次, 为了节约时间, 我们只训练一次&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">batch_size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">64&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">time_step&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">28&lt;/span> &lt;span class="c1"># rnn 时间步数 / 图片高度&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">input_size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">28&lt;/span> &lt;span class="c1"># rnn 每步输入值 / 图片每行像素&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">hidden_size&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">64&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">num_layers&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">num_classes&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">10&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">lr&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mf">0.01&lt;/span> &lt;span class="c1"># learning rate&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">total_step&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">train_loader&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">for&lt;/span> &lt;span class="n">epoch&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">range&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">epochs&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">images&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">labels&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">enumerate&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">train_loader&lt;/span>&lt;span class="p">):&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">images&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">images&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">reshape&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">time_step&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">input_size&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">to&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">device&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">labels&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">labels&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">to&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">device&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># forward pass&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">outputs&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">model&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">images&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">loss&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">criterion&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">outputs&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">labels&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="c1"># backward and optimize&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">optimizer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">zero_grad&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">loss&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">backward&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">optimizer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">step&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">if&lt;/span> &lt;span class="n">i&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="mi">100&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Epoch [&lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s1">/&lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s1">], Step [&lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s1">/&lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s1">], Loss: &lt;/span>&lt;span class="si">{:.4f}&lt;/span>&lt;span class="s1">&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="o">.&lt;/span>&lt;span class="n">format&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">epoch&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">epochs&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">total_step&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">loss&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="p">()))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="215-测试模型" class="relative group">2.1.5 测试模型 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#215-%e6%b5%8b%e8%af%95%e6%a8%a1%e5%9e%8b" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># Test the model&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># https://stackoverflow.com/questions/55627780/evaluating-pytorch-models-with-torch-no-grad-vs-model-eval&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># torch.max()用法。https://blog.csdn.net/weixin_43255962/article/details/84402586&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">model&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">eval&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="k">with&lt;/span> &lt;span class="n">torch&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">no_grad&lt;/span>&lt;span class="p">():&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">correct&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">total&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="k">for&lt;/span> &lt;span class="n">images&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">labels&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="n">test_loader&lt;/span>&lt;span class="p">:&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">images&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">images&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">reshape&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">time_step&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">input_size&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">to&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">device&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">labels&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">labels&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">to&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">device&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">outputs&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">model&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">images&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">predicted&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">torch&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">max&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">outputs&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">data&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">total&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">labels&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">size&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="n">correct&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">predicted&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">labels&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">sum&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">item&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl"> &lt;span class="nb">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Test Accuracy of the model on the 10000 test images: &lt;/span>&lt;span class="si">{}&lt;/span>&lt;span class="s1"> %&amp;#39;&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">format&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">100&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="n">correct&lt;/span> &lt;span class="o">/&lt;/span> &lt;span class="n">total&lt;/span>&lt;span class="p">))&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="22-时间序列预测" class="relative group">2.2 时间序列预测 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#22-%e6%97%b6%e9%97%b4%e5%ba%8f%e5%88%97%e9%a2%84%e6%b5%8b" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>Todo&lt;/p>
&lt;h3 id="23-图像输出文字" class="relative group">2.3 图像输出文字 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#23-%e5%9b%be%e5%83%8f%e8%be%93%e5%87%ba%e6%96%87%e5%ad%97" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>Todo&lt;/p>
&lt;h2 id="补充" class="relative group">补充 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e8%a1%a5%e5%85%85" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ol>
&lt;li>
&lt;p>在原始发表文献用的图示是类似于下图的这种，看起来比较好容易理解当初形成LSTM的原因
&lt;figure>&lt;img src="https://youngforever.tech/images/LSTM/LSTM_O.jpg" alt="LSTM_O" class="mx-auto my-0 rounded-md" />
&lt;/figure>
&lt;/p>
&lt;/li>
&lt;li>
&lt;p>pytorch lstm函数用法示例&lt;/p>
&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="line">&lt;span class="cl">&lt;span class="n">rnn&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nn&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">LSTM&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">10&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">20&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># input_size, hidden_size, num_layers&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">input&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">torch&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">randn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># time_step, batch, input_size（这里input_size即features）&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">h0&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">torch&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">randn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">20&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># num_layers, batch, hidden_size&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">c0&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">torch&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">randn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">20&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># num_layers, batch, hidden_size&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="n">output&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">hn&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">cn&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">rnn&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">input&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">h0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">c0&lt;/span>&lt;span class="p">))&lt;/span> &lt;span class="c1"># output包含从最后一层lstm中输出的ht。shape: time_step, batch, hidden_size&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>&lt;code>hidden_size&lt;/code> is the number of units of your LSTM cell. This means all the layers (input, forget, etc.) will have this size&lt;/p>
&lt;/li>
&lt;li>
&lt;p>hidden_size即pytorch隐含层每个结构中含有的隐含cell数目&lt;/p>
&lt;/li>
&lt;/ul>
&lt;ol start="3">
&lt;li>lstm函数中加入&lt;code>bidirectional=True&lt;/code>参数即双向神经网络&lt;/li>
&lt;/ol>
&lt;h2 id="reference" class="relative group">Reference &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#reference" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ol>
&lt;li>理解LSTM(&lt;a href="http://colah.github.io/posts/2015-08-Understanding-LSTMs/" target="_blank" rel="noreferrer">http://colah.github.io/posts/2015-08-Understanding-LSTMs/&lt;/a>)&lt;/li>
&lt;li>高效RNN(&lt;a href="http://karpathy.github.io/2015/05/21/rnn-effectiveness/" target="_blank" rel="noreferrer">http://karpathy.github.io/2015/05/21/rnn-effectiveness/&lt;/a>)&lt;/li>
&lt;li>Hochreiter &amp;amp; Schmidhuber (1997) LSTM&lt;/li>
&lt;li>Pytorch LSTM官方文档(&lt;a href="https://pytorch.org/docs/stable/nn.html#lstm" target="_blank" rel="noreferrer">https://pytorch.org/docs/stable/nn.html#lstm&lt;/a>)&lt;/li>
&lt;/ol></description></item><item><title>PyTorch深度学习（1）</title><link>https://youngforever.tech/posts/20200305-pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</link><pubDate>Thu, 05 Mar 2020 11:50:19 +0000</pubDate><guid>https://youngforever.tech/posts/20200305-pytorch%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</guid><description>
&lt;script>
document.addEventListener("DOMContentLoaded", function() {
renderMathInElement(document.body, {
delimiters: [
{left: '$$', right: '$$', display: true},
{left: '$', right: '$', display: false},
{left: '\\(', right: '\\)', display: false},
{left: '\\[', right: '\\]', display: true}
],
throwOnError : false
});
});
&lt;/script>
&lt;h2 id="1-history-motivation-and-evolution-of-deep-learning" class="relative group">1. History, motivation and evolution of Deep Learning &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#1-history-motivation-and-evolution-of-deep-learning" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>科学技术发展如海浪一样也会潮起潮落，深度学习在经历了几次低谷后。2010年左右，在语音识别领域取得进展，2012年在计算机视觉领域也发展起来，随后各个领域都开始使用应用深度学习方法，而似乎渐渐抛弃了其他方法，那么深度学习是不是问题的最终解决之道呢？研究方向宽泛而多维才是合理的道路，不应过分追求热点领域。正如上世纪80年代日本学者在低谷时期仍然坚持自己的研究领域。&lt;/p>
&lt;p>学习表征：如何学习好的表征是深度学习要解决的问题之一，原始数据以一种有用的形式返回。自然状态下数据相互依赖有关系的。高效的表达方式应该是每类数据都是完全独立能完全单独表达某个方面。&lt;/p>
&lt;ul>
&lt;li>space tiling&lt;/li>
&lt;li>random projections&lt;/li>
&lt;li>polynomial classifier&lt;/li>
&lt;li>radial basis functions&lt;/li>
&lt;li>kernel machines&lt;/li>
&lt;/ul>
&lt;h2 id="2-gradient-descent-and-backpropagation" class="relative group">2. Gradient Descent and Backpropagation &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#2-gradient-descent-and-backpropagation" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;h3 id="21-gradient-descent" class="relative group">2.1 Gradient Descent &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#21-gradient-descent" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>$$J(w, b) = \frac{1}{m}\sum_1^mL(\hat{y}^{(i)}, y^{i})$$
J(w, b)为问题的cost function即目标函数，即m个样本的损失函数平均值。使目标函数最小得到此时w,b参数是我们的优化问题。&lt;/p>
&lt;h4 id="211-梯度下降batch-gradient-descent" class="relative group">2.1.1 梯度下降(batch gradient descent) &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#211-%e6%a2%af%e5%ba%a6%e4%b8%8b%e9%99%8dbatch-gradient-descent" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h4>&lt;p>梯度下降即上式对所有样本计算求出目标函数，通过对w,b求梯度来找到目标函数最小值，常用的一个比喻即找最快路径下山。数学理解是算法实现的重要一步，但与在计算机上实现还是有区别的，那么实际做法是什么样的呢？&lt;/p>
&lt;p>当你对复杂的问题想不清楚时，我们都可以从一个简单的例子出发来简化问题，对于这个问题考虑只有一个样本时，我们怎么编程实现呢？对w1、 b1，计算一个样本的loss然后对w1、b1求导优化思路很清晰，那么有m个样本的时候呢？只需将其他样本计算loss，然后对w1、b1求导相加。最后在通过学习率来更新w、b。可以看到每次更新都需要进行m次运算&lt;/p>
&lt;h4 id="212-小样本梯度下降mini-batch-gradient-descent" class="relative group">2.1.2 小样本梯度下降（mini-batch gradient descent） &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#212-%e5%b0%8f%e6%a0%b7%e6%9c%ac%e6%a2%af%e5%ba%a6%e4%b8%8b%e9%99%8dmini-batch-gradient-descent" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h4>&lt;p>在每次更新时用n个样本，不用全部的样本。在深度学习中常用这种方法。用mini-batch可以享受向量化带来的便利，也不用全梯度下降那么大计算量，同时这也是应对冗余数据的一种方法。&lt;/p>
&lt;h4 id="213-随机梯度下降stochastic-gradient-descent" class="relative group">2.1.3 随机梯度下降(stochastic gradient descent) &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#213-%e9%9a%8f%e6%9c%ba%e6%a2%af%e5%ba%a6%e4%b8%8b%e9%99%8dstochastic-gradient-descent" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h4>&lt;p>当n = 1的时候，每次更新的时候用1个样本。该方法在大多数情况下比全样本的梯度下降要快。&lt;/p>
&lt;p>三种优化方法最后收敛吗？最后能达到全局最小值吗？这是优化方法都需要考虑到的。可以阅读Optimization Methods for Large-Scale Machine Learning，我自己还没读过&amp;hellip;&lt;/p>
&lt;h3 id="22-backprop" class="relative group">2.2 Backprop &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#22-backprop" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;p>反向传播是为了求梯度用到的微积分链式法则，从而使梯度下降算法运行。&lt;/p>
&lt;h3 id="23-pytorch训练神经网络步骤" class="relative group">2.3 PyTorch训练神经网络步骤 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#23-pytorch%e8%ae%ad%e7%bb%83%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c%e6%ad%a5%e9%aa%a4" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h3>&lt;ol>
&lt;li>output = model(input) 即神经网络前向传播&lt;/li>
&lt;li>J = loss(output, label) 计算cost function&lt;/li>
&lt;li>model.zero_grad() 清除梯度计算&lt;/li>
&lt;li>J.backward() 对requires_grad = True的变量计算梯度&lt;/li>
&lt;li>optimiser.step() 进行梯度下降&lt;/li>
&lt;/ol>
&lt;h2 id="3-总结" class="relative group">3. 总结 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#3-%e6%80%bb%e7%bb%93" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>看了前两节，觉得还是吴恩达大佬讲的好一些。建议网页上快速过内容即可，视频不用细看。&lt;/p></description></item><item><title>Mathematical notation</title><link>https://youngforever.tech/posts/samples/mathematical-notation/</link><pubDate>Fri, 08 Mar 2019 00:00:00 +0000</pubDate><guid>https://youngforever.tech/posts/samples/mathematical-notation/</guid><description>&lt;p>
&lt;script>
document.addEventListener("DOMContentLoaded", function() {
renderMathInElement(document.body, {
delimiters: [
{left: '$$', right: '$$', display: true},
{left: '$', right: '$', display: false},
{left: '\\(', right: '\\)', display: false},
{left: '\\[', right: '\\]', display: true}
],
throwOnError : false
});
});
&lt;/script>
KaTeX can be used to render mathematical notation within articles.&lt;/p>
&lt;h2 id="inline-notation" class="relative group">Inline notation &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#inline-notation" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>Inline notation can be generated by wrapping the expression in &lt;code>\\(&lt;/code> and &lt;code>\\)&lt;/code> delimiters.&lt;/p>
&lt;p>&lt;strong>Example:&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-tex" data-lang="tex">&lt;span class="line">&lt;span class="cl">&lt;span class="c">% KaTeX inline notation
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span>Inline notation: &lt;span class="k">\\&lt;/span>(&lt;span class="k">\varphi&lt;/span> = &lt;span class="k">\dfrac&lt;/span>&lt;span class="nb">{&lt;/span>1+&lt;span class="k">\sqrt&lt;/span>5&lt;span class="nb">}{&lt;/span>2&lt;span class="nb">}&lt;/span>= 1.6180339887…&lt;span class="k">\\&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Inline notation: \(\varphi = \dfrac{1+\sqrt5}{2}= 1.6180339887…\)&lt;/p>
&lt;h2 id="block-notation" class="relative group">Block notation &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#block-notation" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>Alternatively, block notation can be generated using &lt;code>$$&lt;/code> delimiters. This will output the expression in its own HTML block.&lt;/p>
&lt;p>&lt;strong>Example:&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-tex" data-lang="tex">&lt;span class="line">&lt;span class="cl">&lt;span class="c">% KaTeX block notation
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c">&lt;/span>&lt;span class="sb">$$&lt;/span>&lt;span class="nb">
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb"> &lt;/span>&lt;span class="nv">\varphi&lt;/span>&lt;span class="nb"> &lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="nb"> &lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="nv">\frac&lt;/span>&lt;span class="nb">{&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="nb">} {&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="nv">\frac&lt;/span>&lt;span class="nb">{&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="nb">} {&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="nv">\frac&lt;/span>&lt;span class="nb">{&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="nb">} {&lt;/span>&lt;span class="m">1&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="nv">\cdots&lt;/span>&lt;span class="nb">} } }
&lt;/span>&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="nb">&lt;/span>&lt;span class="s">$$&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>$$
\varphi = 1+\frac{1} {1+\frac{1} {1+\frac{1} {1+\cdots} } }
$$&lt;/p></description><media:content xmlns:media="http://search.yahoo.com/mrss/" url="https://youngforever.tech/posts/samples/mathematical-notation/feature-artturi-jalli-gYrYa37fAKI-unsplash.jpg"/></item><item><title>Git常用命令</title><link>https://youngforever.tech/posts/20190304-git/</link><pubDate>Mon, 04 Mar 2019 22:22:22 +0000</pubDate><guid>https://youngforever.tech/posts/20190304-git/</guid><description>&lt;p>以下操作基于macOS，Windows仅供参考。&lt;/p>
&lt;h2 id="git初始化文件夹" class="relative group">git初始化文件夹 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#git%e5%88%9d%e5%a7%8b%e5%8c%96%e6%96%87%e4%bb%b6%e5%a4%b9" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>进入目录&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git init
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="新建gitignore" class="relative group">新建.gitignore &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#%e6%96%b0%e5%bb%bagitignore" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>然后在其中加入需要忽略的文件或文件夹.gitignore
例如public\&lt;/p>
&lt;h2 id="git删除ds_store文件" class="relative group">git删除.DS_Store文件 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#git%e5%88%a0%e9%99%a4ds_store%e6%96%87%e4%bb%b6" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;ol>
&lt;li>从该仓库中删除已存在的DS_Store文件&lt;sup id="fnref:1">&lt;a href="#fn:1" class="footnote-ref" role="doc-noteref">1&lt;/a>&lt;/sup>&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">find . -name .DS_Store -print0 &lt;span class="p">|&lt;/span> xargs -0 git rm -f --ignore-unmatch
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="2">
&lt;li>新建&lt;code>.gitignore_global&lt;/code>文件并将.DS_Store以及*/.DS_Store加入其中&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">vi .gitignore_global
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">&lt;span class="c1"># 写入.DS_Store，*/.DS_Store&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git config --global core.excludesfile ~/.gitignore_global
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="3">
&lt;li>推到仓库&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git add .gitignore
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git commit -m &lt;span class="s1">&amp;#39;.DS_Store banished!&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ol start="4">
&lt;li>检查仓库中是否还有&lt;/li>
&lt;/ol>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git status
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="git删除远程分支文件" class="relative group">git删除远程分支文件 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#git%e5%88%a0%e9%99%a4%e8%bf%9c%e7%a8%8b%e5%88%86%e6%94%af%e6%96%87%e4%bb%b6" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>当我们需要删除暂存区或分支上的文件, 同时工作区也不需要这个文件了, 可以使用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git rm file_path
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>当我们需要删除暂存区或分支上的文件, 但本地又需要使用, 只是不希望这个文件被版本控制, 可以使用&lt;/p>
&lt;pre tabindex="0">&lt;code>git rm –cached file_path
&lt;/code>&lt;/pre>&lt;p>所以我们经常使用以下命令来删除git中的文件&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git rm -r --cached filename
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git commit -m &lt;span class="s1">&amp;#39;delete some file&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push origin master
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="git冲突处理" class="relative group">git冲突处理 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#git%e5%86%b2%e7%aa%81%e5%a4%84%e7%90%86" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>git远程分支修改，本地也修改了准备提交出现冲突&lt;/p>
&lt;ul>
&lt;li>先拉在推
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git pull --rebase &lt;span class="c1">#检查合并是否冲突&lt;/span>
&lt;/span>&lt;/span>&lt;span class="line">&lt;span class="cl">git push -u origin master
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>强制按本地更新
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git push -f
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="git子模块submodule" class="relative group">git子模块（submodule） &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#git%e5%ad%90%e6%a8%a1%e5%9d%97submodule" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>对于公共资源或者常用的代码，你可能会把最新版本逐个复制到N个项目中，如果使用了submodule模块，那么只需要在各个项目中&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="line">&lt;span class="cl">git submodule update
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>进入子模块目录正常操作即可&lt;/p>
&lt;h2 id="git多账户切换" class="relative group">git多账户切换 &lt;span class="absolute top-0 w-6 transition-opacity opacity-0 -start-6 not-prose group-hover:opacity-100">&lt;a class="group-hover:text-primary-300 dark:group-hover:text-neutral-700" style="text-decoration-line: none !important;" href="#git%e5%a4%9a%e8%b4%a6%e6%88%b7%e5%88%87%e6%8d%a2" aria-label="Anchor">#&lt;/a>&lt;/span>&lt;/h2>&lt;p>删除keychain access种存储账户&lt;/p>
&lt;div class="footnotes" role="doc-endnotes">
&lt;hr>
&lt;ol>
&lt;li id="fn:1">
&lt;p>&lt;a href="https://www.jianshu.com/p/e3d8eb2a4295" target="_blank" rel="noreferrer"> Git删除.DS_Store&lt;/a>&amp;#160;&lt;a href="#fnref:1" class="footnote-backref" role="doc-backlink">&amp;#x21a9;&amp;#xfe0e;&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;/div></description></item></channel></rss>